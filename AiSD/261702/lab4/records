{"version": 2, "width": 158, "height": 41, "timestamp": 1653343042, "env": {"SHELL": "/bin/bash", "TERM": "xterm-256color"}}
[0.039063, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab4\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab4\u001b[00m$ "]
[1.236631, "o", "l"]
[1.380525, "o", "s"]
[1.630238, "o", "\r\n"]
[1.632874, "o", "asco_gene.cpp   \u001b[0m\u001b[01;32mbst\u001b[0m    bst.h      generator_tests.cpp  RBTree.c  red_black_tree.h  Splay.c  testy_bst_sorted.sh    \u001b[01;32mtesty_splay_sorted.sh\u001b[0m\r\n\u001b[01;32masco_generator\u001b[0m  BST.c  \u001b[01;32mgenerator\u001b[0m  \u001b[01;32mrbtree\u001b[0m               records   \u001b[01;32msplay\u001b[0m             splay.h  \u001b[01;32mtesty_bst_unsorted.sh\u001b[0m  \u001b[01;32mtesty_splay_unsorted.sh\u001b[0m\r\n"]
[1.633315, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab4\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab4\u001b[00m$ "]
[2.575217, "o", "c"]
[2.795235, "o", "a"]
[2.953496, "o", "t"]
[4.043991, "o", " "]
[4.656067, "o", "."]
[4.870829, "o", "/"]
[6.157859, "o", "b"]
[6.39387, "o", "s"]
[6.608163, "o", "t"]
[8.010358, "o", "\b\u001b[K"]
[8.200779, "o", "\b\u001b[K"]
[8.374818, "o", "\b\u001b[K"]
[9.100161, "o", "B"]
[9.350632, "o", "S"]
[9.599494, "o", "T"]
[10.351103, "o", "."]
[10.786731, "o", "c"]
[11.488368, "o", "\r\n"]
[11.489741, "o", "// Binary Search Tree operations in C\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"bst.h\"\r\n\r\nstatic double comparisions = 0;\r\nstatic double read_pointers = 0;\r\n\r\nstatic double curr_height = 0;\r\nstatic double maks_height = 0;\r\n// TODO: \r\n// search\r\n// min/maks\r\n// insert\r\n// delete\r\n\r\n// Jako miary złożoności zliczaj: \r\n\r\n// liczby porównań między kluczami, ez\r\n\r\n// liczby odczytów i podstawień wskaźników łączących elementy struktury drzewa, // ??\r\n\r\n// wysokość drzewa po każdej operacji.\r\n\r\n\r\n// Create a node\r\nstruct node *newNode(int item) {\r\n  struct node *temp = (struct node *)malloc(sizeof(struct node));\r\n  temp->key = item;\r\n  temp->left = temp->right = NULL;\r\n  read_pointers++;\r\n  return temp;\r\n}\r\n\r\ndouble tree_height(struct node* root)\r\n{\r\n    if (root == NULL)\r\n    {\r\n       return -1;\r\n    }\r\n    else\r\n    {\r\n        // compute the depth of each subtree \r\n        double lDepth = tree_height(root->left);\r\n        double rDepth = tree_height(root->right);\r\n \r\n        // use the"]
[11.489927, "o", " larger one\r\n        if (lDepth > rDepth)\r\n            return (lDepth + 1);\r\n        else\r\n            return (rDepth + 1);\r\n    }\r\n}\r\n\r\n// Inorder Traversal\r\nvoid inorder(struct node *root) {\r\n  if (root != NULL) {\r\n    // Traverse left\r\n    inorder(root->left);\r\n\r\n    // Traverse root\r\n    printf(\"%d -> \", root->key);\r\n\r\n    // Traverse right\r\n    inorder(root->right);\r\n  }\r\n}\r\n\r\n// Insert a node\r\nstruct node *insert(struct node *node, int key) {\r\n  // Return a new node if the tree is empty\r\n  comparisions++;\r\n  if (node == NULL){\r\n    curr_height++;\r\n    return newNode(key);\r\n  } \r\n\r\n  // Traverse to the right place and insert the node\r\n  comparisions++;\r\n  curr_height++;\r\n  if (key < node->key)\r\n    node->left = insert(node->left, key);\r\n  else\r\n    node->right = insert(node->right, key);\r\n\r\n  return node;\r\n}\r\n\r\n// Find the inorder successor\r\nstruct node *minValueNode(struct node *node) {\r\n    struct node *current = node;\r\n\r\n    // Find the leftmost leaf\r\n    read_pointers+=2;\r\n    while (current && curre"]
[11.490019, "o", "nt->left != NULL){\r\n      read_pointers+=3;\r\n      current = current->left;\r\n    }\r\n    \r\n\r\n  return current;\r\n}\r\n\r\n// Deleting a node\r\nstruct node *deleteNode(struct node *root, int key, struct node *parrent) {\r\n  \r\n  // Return if the tree is empty\r\n  read_pointers++;\r\n  if (root == NULL) return root;\r\n\r\n  // Find the node to be deleted\r\n  comparisions++;\r\n  if (key < root->key){\r\n    parrent = root;\r\n    root->left = deleteNode(root->left, key, parrent);\r\n  }\r\n  else if (key > root->key){\r\n    //parrent = root;\r\n    root->right = deleteNode(root->right, key, parrent);\r\n  }\r\n  else {\r\n    // If the node is with only one child or no child\r\n    \r\n    read_pointers++;\r\n    if (root->left == NULL) {\r\n      read_pointers++;\r\n      struct node *temp = root->right;\r\n      free(root);\r\n      // if(parrent != NULL){\r\n      //   printf(\"parent of deleted node: %d \\n\", parrent->key);\r\n      // }\r\n      return temp;\r\n    } \r\n    else if (root->right == NULL) {\r\n      read_pointers+=2;\r\n      struct node *temp = root->le"]
[11.490105, "o", "ft;\r\n      free(root);\r\n      // if(parrent != NULL){\r\n      //   printf(\"parent of deleted node: %d \\n\", parrent->key);\r\n      // }\r\n      return temp;\r\n    }\r\n\r\n    // If the node has two children\r\n    struct node *temp = minValueNode(root->right);\r\n\r\n    // Place the inorder successor in position of the node to be deleted\r\n    read_pointers++;\r\n    root->key = temp->key;\r\n\r\n    // Delete the inorder successor\r\n    \r\n    // if(parrent != NULL){\r\n    //   printf(\"parent of deleted node: %d \\n\", parrent->key);\r\n    // }\r\n    \r\n    // parrent = root;\r\n    root->right = deleteNode(root->right, temp->key, parrent);\r\n  }\r\n  \r\n  return root;\r\n}\r\n\r\nvoid free_subtree(struct node** root){\r\n  if( *root == NULL ) return;\r\n  if( (*root)->left != NULL ){\r\n    free_subtree( &(*root)->left );\r\n  }\r\n  if( (*root)->right != NULL ){\r\n    free_subtree( &(*root)->right );\r\n  }\r\n  free(*root);\r\n  *root=NULL;  \r\n}\r\n\r\n// global variables used in `print_BST`\r\nstatic char* left_trace; // needs to be allocaded with mysize\r\nstatic cha"]
[11.490185, "o", "r* right_trace; // needs to be allocaded with mysize\r\n\r\n\r\nvoid print_BST( struct node * root, int depth, char prefix){\r\n  if( root == NULL ) return;\r\n  if( root->left != NULL ){\r\n    print_BST(root->left, depth+1, '/');\r\n  }\r\n  if(prefix == '/') left_trace[depth-1]='|';\r\n  if(prefix == '\\\\') right_trace[depth-1]=' ';\r\n  if( depth==0) printf(\"-\");\r\n  if( depth>0) printf(\" \");\r\n  for(int i=0; i<depth-1; i++)\r\n    if( left_trace[i]== '|' || right_trace[i]=='|' ) {\r\n      //printf(\"| \\n\");\r\n      printf(\"| \");\r\n    } else {\r\n      //printf(\"  \\n\");\r\n      printf(\"  \");\r\n    }\r\n  if( depth>0 ) printf(\"%c-\", prefix);\r\n  printf(\"[%d]\\n\", root->key);\r\n  left_trace[depth]=' ';\r\n  if( root->right != NULL ){\r\n    right_trace[depth]='|';\r\n    print_BST(root->right, depth+1, '\\\\');\r\n  }\r\n}\r\n\r\n\r\n// Driver code\r\nint main() {\r\n  struct node *root = NULL;\r\n  struct node *parrent = NULL;\r\n  int n, k;\r\n  double height = 0;\r\n  double sum_c = 0;\r\n  double maks_c = 0;\r\n  double sum_r = 0;\r\n  double maks_r = 0;\r\n  double sum_h = 0;"]
[11.490325, "o", "\r\n  double maks_h = 0;\r\n\r\n  // root = insert(root, 8);\r\n  // root = insert(root, 3);\r\n  // root = insert(root, 1);\r\n  // root = insert(root, 6);\r\n  // root = insert(root, 7);\r\n  // root = insert(root, 10);\r\n  // root = insert(root, 14);\r\n  // root = insert(root, 4);\r\n\r\n  \r\n\r\n  scanf(\"%d\", &n);\r\n\r\n  unsigned long mysize = n;\r\n  //size_t dupa = 2;\r\n\r\n\r\n    // init traces\r\n  left_trace = (char*)malloc( (sizeof(char) ) * mysize + 1);\r\n  right_trace = (char*)malloc( (sizeof(char) ) * mysize + 1 );\r\n  for(unsigned int i=0; i<=mysize; i++){\r\n    left_trace[i]=' ';\r\n    right_trace[i]=' ';\r\n  }\r\n  printf(\"inserting: \\n\");\r\n  for(int i = 0; i < n; i++){\r\n    scanf(\"%d\", &k);\r\n    root = insert(root, k);\r\n    printf(\"\\n\");\r\n    print_BST(root, 0, '-');\r\n    printf(\"\\n\");\r\n    //height = tree_height(root);\r\n    if(comparisions >= maks_c) maks_c = comparisions;\r\n    if(read_pointers >= maks_r) maks_r = read_pointers;\r\n    if(curr_height >= maks_height) maks_height = curr_height;\r\n    sum_c+= comparisions;\r\n    sum_r+= re"]
[11.490426, "o", "ad_pointers;\r\n    sum_h+= maks_height;\r\n    \r\n\r\n    //printf(\"%d, %d, %d, %d \\n\", n, comparisions, read_pointers, height );\r\n    curr_height = 0;\r\n    comparisions = 0;\r\n    read_pointers = 0;\r\n  }\r\n    \r\n    maks_h = maks_height;\r\n    printf(\"deleting: \\n\");\r\n    for(int i = 0; i < n; i++){\r\n    scanf(\"%d\", &k);\r\n    root = deleteNode(root, k, parrent);\r\n    printf(\"\\n\");\r\n    print_BST(root, 0, '-');\r\n    printf(\"\\n\");\r\n    height = tree_height(root);\r\n    if(comparisions >= maks_c) maks_c = comparisions;\r\n    if(read_pointers >= maks_r) maks_r = read_pointers;\r\n    //if(curr_height >= maks_height) maks_height = curr_height;\r\n    sum_c+= comparisions;\r\n    sum_r+= read_pointers;\r\n    sum_h+= height;\r\n    \r\n\r\n    //printf(\"%d, %d, %d, %d \\n\", n, comparisions, read_pointers, height );\r\n    //curr_height = 0;\r\n    comparisions = 0;\r\n    read_pointers = 0;\r\n  }\r\n\r\n\r\n\r\n  // printf(\"TREE:\\n\\n\");\r\n  // print_BST(root, 0, '-');\r\n  // printf(\"\\n\\n\");\r\n\r\n  // printf(\"Inorder traversal: \");\r\n  // inorder(root);\r\n\r\n  /"]
[11.490506, "o", "/ printf(\"\\nAfter deleting 14\\n\");\r\n  // root = deleteNode(root, 14, parrent);\r\n\r\n  // printf(\"TREE:\\n\\n\");\r\n  // print_BST(root, 0, '-');\r\n  // printf(\"\\n\\n\");\r\n\r\n  // printf(\"Inorder traversal: \");\r\n  // inorder(root);\r\n  // printf(\"\\n\");\r\n\r\n  double height_avg = sum_h/(2*n);\r\n  double comp_avg = sum_c/(2*n);\r\n  double reads_avg = sum_r/(2*n);\r\n\r\n  //printf(\"size_n,  comp_avg,  comp_maks, reads_avg, reads_maks, h_avg,   h_final   h_maks \\n\");\r\n  printf(\"%d, %f, %f, %f, %f, %f, %f, %f \\n\", n, comp_avg, maks_c, reads_avg, maks_r, height_avg, height, maks_height);\r\n\r\n\r\n\r\n  free(left_trace);\r\n  free(right_trace);\r\n  free_subtree(&root);\r\n\r\n  //printf(\"\\n sizeof char: %ld \\n\", sizeof(char));\r\n}\r\n"]
[11.490579, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab4\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab4\u001b[00m$ "]
[12.740225, "o", "cat ./BST.c"]
[13.368824, "o", "\b"]
[13.586828, "o", "\b"]
[14.174983, "o", "\b\u001b[1P.c\b\b"]
[14.378652, "o", "\b\u001b[1P.c\b\b"]
[14.567847, "o", "\b\u001b[1P.c\b\b"]
[15.245097, "o", "S.c\b\b"]
[15.493701, "o", "p.c\b\b"]
[15.699201, "o", "l.c\b\b"]
[15.827326, "o", "a.c\b\b"]
[16.689503, "o", "y.c\b\b"]
[17.450178, "o", "\r\n"]
[17.452052, "o", "// splay tree\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"splay.h\"\r\n\r\n\r\nstatic double comparisions = 0;\r\nstatic double read_pointers = 0;\r\n\r\n// Create a node\r\nstruct node *newNode(int item) {\r\n  struct node *temp = (struct node *)malloc(sizeof(struct node));\r\n  temp->key = item;\r\n  temp->left = temp->right = NULL;\r\n  read_pointers++;\r\n  return temp;\r\n}\r\n\r\nvoid free_subtree(struct node** root){\r\n  if( *root == NULL ) return;\r\n  if( (*root)->left != NULL ){\r\n    free_subtree( &(*root)->left );\r\n  }\r\n  if( (*root)->right != NULL ){\r\n    free_subtree( &(*root)->right );\r\n  }\r\n  free(*root);\r\n  *root=NULL;  \r\n}\r\n\r\n// global variables used in `print_BST`\r\nstatic char* left_trace; // needs to be allocaded with mysize\r\nstatic char* right_trace; // needs to be allocaded with mysize\r\n\r\n\r\nvoid print_BST( struct node * root, int depth, char prefix){\r\n    if( root == NULL ) return;\r\n\r\n    if( root->left != NULL ){\r\n        print_BST(root->left, depth+1, '/');\r\n    }\r\n    if(prefix == '/') left_trace[depth-1]='|'"]
[17.452128, "o", ";\r\n    if(prefix == '\\\\') right_trace[depth-1]=' ';\r\n    if( depth==0) printf(\"-\");\r\n    if( depth>0) printf(\" \");\r\n\r\n    for(int i=0; i<depth-1; i++){\r\n        if( left_trace[i]== '|' || right_trace[i]=='|' ) {\r\n        //printf(\"| \\n\");\r\n        printf(\"| \");\r\n        } \r\n        else {\r\n        //printf(\"  \\n\");\r\n        printf(\"  \");\r\n        }\r\n    }\r\n    if( depth>0 ) printf(\"%c-\", prefix);\r\n\r\n    printf(\"[%d]\\n\", root->key);\r\n    left_trace[depth]=' ';\r\n\r\n    if( root->right != NULL ){\r\n        right_trace[depth]='|';\r\n        print_BST(root->right, depth+1, '\\\\');\r\n    }\r\n}\r\n\r\n// A utility function to right rotate subtree rooted with y\r\n// See the diagram given above.\r\nstruct node *rightRotate(struct node *x)\r\n{\r\n    struct node *y = x->left;\r\n    x->left = y->right;\r\n    y->right = x;\r\n    read_pointers+=3;\r\n    return y;\r\n}\r\n \r\n// A utility function to left rotate subtree rooted with x\r\n// See the diagram given above.\r\nstruct node *leftRotate(struct node *x)\r\n{\r\n    struct node *y = x->right;\r\n    x"]
[17.452151, "o", "->right = y->left;\r\n    y->left = x;\r\n    read_pointers+=3;\r\n    return y;\r\n}\r\n\r\n// Find the inorder successor\r\nstruct node *minValueNode(struct node *node) {\r\n    struct node *current = node;\r\n\r\n  // Find the leftmost leaf\r\n     read_pointers+=2;\r\n     while (current && current->left != NULL){\r\n        read_pointers+=3;\r\n        current = current->left;\r\n        }\r\n\r\n    return current;\r\n}\r\n \r\n// This function brings the key at root if key is present in tree.\r\n// If key is not present, then it brings the last accessed item at\r\n// root.  This function modifies the tree and returns the new root\r\nstruct node *splay(struct node *root, int key)\r\n{\r\n    // Base cases: root is NULL or key is present at root\r\n    read_pointers++;\r\n    comparisions++;\r\n    if (root == NULL || root->key == key)\r\n        return root;\r\n \r\n    // Key lies in left subtree\r\n    //read_pointers++;\r\n    comparisions++;\r\n    if (root->key > key)\r\n    {\r\n        // Key is not in tree, we are done\r\n        read_pointers++;\r\n        if (root->le"]
[17.45218, "o", "ft == NULL) return root;\r\n \r\n        // Zig-Zig (Left Left)\r\n        comparisions++;\r\n        if (root->left->key > key)\r\n        {\r\n            // First recursively bring the key as root of left-left\r\n            root->left->left = splay(root->left->left, key);\r\n \r\n            // Do first rotation for root, second rotation is done after else\r\n            root = rightRotate(root);\r\n        }\r\n        else if (root->left->key < key) // Zig-Zag (Left Right)\r\n        {\r\n            comparisions++;\r\n            // First recursively bring the key as root of left-right\r\n            read_pointers++;\r\n            root->left->right = splay(root->left->right, key);\r\n \r\n            // Do first rotation for root->left\r\n            read_pointers++;\r\n            if (root->left->right != NULL)\r\n                root->left = leftRotate(root->left);\r\n        }\r\n \r\n        // Do second rotation for root\r\n        read_pointers++;\r\n        return (root->left == NULL)? root: rightRotate(root);\r\n    }\r\n    else // Key lies in right"]
[17.452192, "o", " subtree\r\n    {\r\n        // Key is not in tree, we are done\r\n        read_pointers++;\r\n        if (root->right == NULL) return root;\r\n \r\n        // Zig-Zag (Right Left)\r\n        comparisions++;\r\n        if (root->right->key > key)\r\n        {\r\n            // Bring the key as root of right-left\r\n            read_pointers++;\r\n            root->right->left = splay(root->right->left, key);\r\n \r\n            // Do first rotation for root->right\r\n            read_pointers++;\r\n            if (root->right->left != NULL)\r\n                root->right = rightRotate(root->right);\r\n        }\r\n        else if (root->right->key < key)// Zag-Zag (Right Right)\r\n        {   comparisions++;\r\n            // Bring the key as root of right-right and do first rotation\r\n            read_pointers++;\r\n            root->right->right = splay(root->right->right, key);\r\n            root = leftRotate(root);\r\n        }\r\n \r\n        // Do second rotation for root\r\n        return (root->right == NULL)? root: leftRotate(root);\r\n    }\r\n}\r\n\r\nstruct "]
[17.452204, "o", "node *insert(struct node *root, int k)\r\n{\r\n    // Simple Case: If tree is empty\r\n    read_pointers++;\r\n    if (root == NULL) return newNode(k);\r\n \r\n    // Bring the closest leaf node to root\r\n    root = splay(root, k);\r\n \r\n    // If key is already present, then return\r\n    comparisions++;\r\n    if (root->key == k) return root;\r\n \r\n    // Otherwise allocate memory for new node\r\n    struct node *newnode  = newNode(k);\r\n \r\n    // If root's key is greater, make root as right child\r\n    // of newnode and copy the left child of root to newnode\r\n    comparisions++;\r\n    if (root->key > k)\r\n    {\r\n        read_pointers+=3;\r\n        newnode->right = root;\r\n        newnode->left = root->left;\r\n        root->left = NULL;\r\n    }\r\n \r\n    // If root's key is smaller, make root as left child\r\n    // of newnode and copy the right child of root to newnode\r\n    else\r\n    {\r\n        read_pointers+=3;\r\n        newnode->left = root;\r\n        newnode->right = root->right;\r\n        root->right = NULL;\r\n    }\r\n \r\n    return newnode; "]
[17.452217, "o", "// newnode becomes new root\r\n}\r\n \r\n// A utility function to print preorder traversal of the tree.\r\n// The function also prints height of every node\r\nvoid preOrder(struct node *root)\r\n{\r\n    if (root != NULL)\r\n    {\r\n        printf(\"%d \", root->key);\r\n        preOrder(root->left);\r\n        preOrder(root->right);\r\n    }\r\n}\r\n\r\n\r\nstruct node* delete_key(struct node *root, int key)\r\n{\r\n    read_pointers++;\r\n    struct node *temp;\r\n    if (!root)\r\n        return NULL;\r\n      \r\n    // Splay the given key    \r\n    read_pointers++;\r\n    root = splay(root, key);\r\n      \r\n    // If key is not present, then\r\n    // return root\r\n    comparisions++;\r\n    if (key != root->key)\r\n        return root;\r\n          \r\n    // If key is present\r\n    // If left child of root does not exist\r\n    // make root->right as root   \r\n    read_pointers++;\r\n    if (!root->left)\r\n    {   read_pointers+=2;\r\n        temp = root;\r\n        root = root->right;\r\n    }\r\n      \r\n    // Else if left child exits\r\n    else\r\n    {\r\n\r\n        temp = root;\r\n"]
[17.452233, "o", "  \r\n        /*Note: Since key == root->key,\r\n        so after Splay(key, root->lchild),\r\n        the tree we get will have no right child tree\r\n        and maximum node in left subtree will get splayed*/\r\n        // New root\r\n        read_pointers++;\r\n        root = splay(root->left, key);\r\n          \r\n        // Make right child of previous root  as\r\n        // new root's right child\r\n        read_pointers+=2;\r\n        root->right = temp->right;\r\n    }\r\n      \r\n    // free the previous root node, that is,\r\n    // the node containing the key\r\n    free(temp);\r\n      \r\n    // return root of the new Splay Tree\r\n    return root;\r\n      \r\n}\r\n\r\nstruct node *search(struct node *root, int key)\r\n{\r\n    return splay(root, key);\r\n}\r\n\r\ndouble tree_height(struct node* root)\r\n{\r\n    if (root == NULL)\r\n    {\r\n       return -1;\r\n    }\r\n    else\r\n    {\r\n        // compute the depth of each subtree \r\n        double lDepth = tree_height(root->left);\r\n        double rDepth = tree_height(root->right);\r\n \r\n        // use the large"]
[17.452254, "o", "r one\r\n        if (lDepth > rDepth)\r\n            return (lDepth + 1);\r\n        else\r\n            return (rDepth + 1);\r\n    }\r\n}\r\n\r\n\r\n \r\n// Driver code\r\nint main() {\r\n  struct node *root = NULL;\r\n  //struct node *parrent = NULL;\r\n  int n, k;\r\n  double height = 0;\r\n  double sum_c = 0;\r\n  double maks_c = 0;\r\n  double sum_r = 0;\r\n  double maks_r = 0;\r\n  double sum_h = 0;\r\n  double maks_h = 0;\r\n\r\n  scanf(\"%d\", &n);\r\n\r\n\r\n  unsigned long mysize = n;\r\n  //size_t dupa = 2;\r\n\r\n\r\n    // init traces\r\n  left_trace = (char*)malloc( (sizeof(char) ) * mysize + 1);\r\n  right_trace = (char*)malloc( (sizeof(char) ) * mysize + 1 );\r\n  for(unsigned int i=0; i<=mysize; i++){\r\n    left_trace[i]=' ';\r\n    right_trace[i]=' ';\r\n  }\r\n\r\n  printf(\"inserting: \\n\");\r\n  for(int i = 0; i < n; i++){\r\n    scanf(\"%d\", &k);\r\n    root = insert(root, k);\r\n    printf(\"\\n\");\r\n    print_BST(root, 0, '-');\r\n    printf(\"\\n\");\r\n\r\n   if(i < 2049 ){\r\n        height = tree_height(root);\r\n    }\r\n    else if(i%50 == 0){\r\n        height = tree_height(root);\r\n "]
[17.452273, "o", "   }\r\n    \r\n    if(comparisions >= maks_c) maks_c = comparisions;\r\n    if(read_pointers >= maks_r) maks_r = read_pointers;\r\n    //if(curr_height >= maks_height) maks_height = curr_height;\r\n    sum_c+= comparisions;\r\n    sum_r+= read_pointers;\r\n    sum_h+= height;\r\n    \r\n\r\n    //printf(\"%d, %d, %d, %d \\n\", n, comparisions, read_pointers, height );\r\n    //curr_height = 0;\r\n    comparisions = 0;\r\n    read_pointers = 0;\r\n  }\r\n    \r\n    maks_h = height;\r\n    printf(\"deleting: \\n\");\r\n    for(int i = 0; i < n; i++){\r\n    scanf(\"%d\", &k);\r\n    root = delete_key(root, k);\r\n    printf(\"\\n\");\r\n    print_BST(root, 0, '-');\r\n    printf(\"\\n\");\r\n    if(i < 2049 ){\r\n        height = tree_height(root);\r\n    }\r\n    else if(i%50 == 0){\r\n        height = tree_height(root);\r\n    }\r\n    \r\n    if(comparisions >= maks_c) maks_c = comparisions;\r\n    if(read_pointers >= maks_r) maks_r = read_pointers;\r\n    //if(curr_height >= maks_height) maks_height = curr_height;\r\n    sum_c+= comparisions;\r\n    sum_r+= read_pointers;\r\n    sum_h+= he"]
[17.452289, "o", "ight;\r\n    \r\n\r\n    //printf(\"%d, %d, %d, %d \\n\", n, comparisions, read_pointers, height );\r\n    //curr_height = 0;\r\n    comparisions = 0;\r\n    read_pointers = 0;\r\n  }\r\n\r\n\r\n\r\n\r\n  double height_avg = sum_h/(2*n);\r\n  double comp_avg = sum_c/(2*n);\r\n  double reads_avg = sum_r/(2*n);\r\n\r\n  //printf(\"size_n,  comp_avg,  comp_maks, reads_avg, reads_maks, h_avg,   h_final   h_maks \\n\");\r\n  printf(\"%d, %f, %f, %f, %f, %f, %f, %f \\n\", n, comp_avg, maks_c, reads_avg, maks_r, height_avg, height, maks_h);\r\n\r\n\r\n  free(left_trace);\r\n  free(right_trace);\r\n  free_subtree(&root);\r\n\r\n\r\n}\r\n"]
[17.452658, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab4\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab4\u001b[00m$ "]
[19.298074, "o", "cat ./Splay.c"]
[20.10844, "o", "\b"]
[20.332223, "o", "\b"]
[20.852199, "o", "\b\u001b[1P.c\b\b"]
[21.025089, "o", "\b\u001b[1P.c\b\b"]
[21.184195, "o", "\b\u001b[1P.c\b\b"]
[21.35803, "o", "\b\u001b[1P.c\b\b"]
[21.582693, "o", "\b\u001b[1P.c\b\b"]
[22.573352, "o", "R.c\b\b"]
[23.658924, "o", "B.c\b\b"]
[24.270165, "o", "T.c\b\b"]
[24.526269, "o", "r.c\b\b"]
[24.694416, "o", "e.c\b\b"]
[24.889797, "o", "e.c\b\b"]
[25.583903, "o", "\r\n"]
[25.587078, "o", "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n#include \"red_black_tree.h\"\r\n\r\nstatic Node* T_nil = NULL;      /* wartownik */\r\nstatic Node* root = NULL;\r\n\r\nstatic double comparisions = 0;\r\nstatic double read_pointers = 0;\r\n\r\nNode* new_Node(int key)\r\n{\r\n    /*    (typ zminnej)malloc(rozmiar podnego typu)    */ \r\n    Node* new = (Node*)malloc(sizeof(Node));\r\n    new->key = key;\r\n    new->color = 'B';\r\n    new->parent = T_nil;\r\n    new->left = T_nil;\r\n    new->right = T_nil;\r\n \r\n    return new;\r\n}\r\n\r\nvoid left_rotate(Node* x)\r\n{\r\n    \r\n    Node* y = x->right;     /* Inicjuj y */ \r\n    x->right = y->left;     /* Zamien lewe poddrzewo y na prawe poddrzewo x */\r\n    read_pointers+=3;\r\n    if (y->left != T_nil)\r\n    {\r\n        y->left->parent = x;\r\n        read_pointers++;\r\n    }\r\n    y->parent = x->parent;  /* Ojcem y uczyń ojca x */\r\n    read_pointers++;\r\n    if (x->parent == T_nil)\r\n    {\r\n        root = y;\r\n        read_pointers+=2;\r\n    }\r\n    else if (x == x->parent->left)\r\n    {\r\n        x->pa"]
[25.587227, "o", "rent->left = y;\r\n        read_pointers+=3;\r\n    }\r\n    else if (x == x->parent->right) // git\r\n    {\r\n        x->parent->right = y;\r\n        read_pointers+=4;\r\n    }\r\n    read_pointers=+2;\r\n    y->left = x;            /* Przyłącz x jako lewego syna y */\r\n    x->parent = y;\r\n}\r\n\r\nvoid right_rotate(Node* x){\r\n\r\n    Node* y;\r\n    y = x->left;     /* Inicjuj y */ \r\n    x->left = y->right;     /* Zamien prawe poddrzewo y na lewe poddrzewo x */\r\n    read_pointers+=3;\r\n    if (y->right != T_nil)\r\n    {\r\n        y->right->parent = x;\r\n        read_pointers++;\r\n    }\r\n    y->parent = x->parent;  /* Ojcem y uczyń ojca x */ \r\n    if (x->parent == T_nil)\r\n    {\r\n        root = y;\r\n        read_pointers+=2;\r\n    }\r\n    else if (x == x->parent->right)\r\n    {\r\n        x->parent->right = y;\r\n        read_pointers+=3;\r\n    }\r\n    else if (x == x->parent->left)\r\n    {\r\n        x->parent->left = y;\r\n        read_pointers+=4;\r\n    }\r\n    read_pointers=+2;\r\n    y->right = x;            /* Przyłącz x jako prawgo syna y */\r\n  "]
[25.587246, "o", "  x->parent = y;\r\n}\r\n\r\nvoid insert_Node(int key){\r\n \r\n    if (root == NULL)\r\n    {   \r\n        root = new_Node(key);\r\n        return;\r\n    }\r\n    \r\n    Node* z = new_Node(key);\r\n    Node* y = T_nil;\r\n    Node* x = root;\r\n    read_pointers+=3;\r\n    while (x != T_nil)\r\n    {\r\n        y = x;\r\n        comparisions++;\r\n        if (z->key < x->key)\r\n        {\r\n            x = x->left;\r\n        }\r\n        else\r\n        {\r\n            x = x->right;\r\n        }\r\n        read_pointers+=2;\r\n    }\r\n    read_pointers++;\r\n    z->parent = y;\r\n    if (y == T_nil)\r\n    {\r\n        root = z;\r\n        read_pointers+=2;\r\n    }\r\n    else if (z->key < y->key)\r\n    {\r\n        y->left = z;\r\n        read_pointers++;\r\n        comparisions++;\r\n    }\r\n    else\r\n    {\r\n        y->right = z;\r\n        comparisions++;\r\n    }\r\n    read_pointers+=2;\r\n    z->left = T_nil;\r\n    z->right = T_nil;\r\n    z->color = 'R';\r\n    \r\n    insert_fixup(z);\r\n} \r\n\r\nvoid insert_fixup(Node* z)\r\n{ \r\n    read_pointers++;\r\n    Node* y = NULL;\r\n    while (z->parent->"]
[25.587262, "o", "color == 'R') // ok\r\n    {\r\n        read_pointers++;\r\n        if (z->parent == z->parent->parent->left)\r\n        {\r\n            y = z->parent->parent->right;\r\n            read_pointers++;\r\n            if (y->color == 'R')\r\n            {\r\n                z->parent->color = 'B';                 /* Przypadek 1 */ \r\n                y->color = 'B';                         /* Przypadek 1 */ \r\n                z->parent->parent->color = 'R';         /* Przypadek 1 */ \r\n                z = z->parent->parent;                  /* Przypadek 1 */ \r\n                read_pointers++;\r\n            } // ok\r\n            else \r\n            {\r\n                read_pointers++;\r\n                if (z == z->parent->right)\r\n                {\r\n                    read_pointers++;\r\n                    z = z->parent;                      /* Przypadek 2 */ \r\n                    left_rotate(z);                /* Przypadek 2 */\r\n                }\r\n                z->parent->color = 'B';                 /* Przypadek 3 */\r\n                z-"]
[25.587282, "o", ">parent->parent->color = 'R';         /* Przypadek 3 */\r\n                right_rotate(z->parent->parent);  /* Przypadek 3 */\r\n            }\r\n        } //ok\r\n        else if (z->parent == z->parent->parent->right)\r\n        {\r\n            y = z->parent->parent->left;\r\n            read_pointers++;\r\n            if (y->color == 'R')\r\n            {\r\n                z->parent->color = 'B';                 /* Przypadek 4 */ \r\n                y->color = 'B';                         /* Przypadek 4 */ \r\n                z->parent->parent->color = 'R';         /* Przypadek 4 */ \r\n                z = z->parent->parent;                  /* Przypadek 4 */\r\n                read_pointers++; \r\n            }\r\n            else \r\n            {\r\n                read_pointers++;\r\n                if (z == z->parent->left)\r\n                {\r\n                    read_pointers++;\r\n                    z = z->parent;                      /* Przypadek 5 */ \r\n                    right_rotate(z);              /* Przypadek 5 */\r\n           "]
[25.588298, "o", "     }\r\n                z->parent->color = 'B';                 /* Przypadek 6 */\r\n                z->parent->parent->color = 'R';         /* Przypadek 6 */\r\n                left_rotate(z->parent->parent);   /* Przypadek 6 */\r\n            }\r\n        }\r\n        read_pointers++;\r\n    }\r\n    root->color = 'B'; \r\n}\r\n\r\nvoid transplant(Node* u, Node* v)\r\n{\r\n    read_pointers++;\r\n    if (u->parent == T_nil)\r\n    {\r\n        root = v;\r\n    }\r\n    else if (u == u->parent->left)\r\n    {\r\n        u->parent->left = v;\r\n        read_pointers++;\r\n    }\r\n    else\r\n    {\r\n        u->parent->right = v;\r\n        read_pointers++;\r\n    }\r\n    v->parent = u->parent;\r\n    read_pointers++;\r\n}\r\n\r\nNode* tree_search(Node* node, int key){\r\n    comparisions++;\r\n    read_pointers++;\r\n    if (node == T_nil || key == node->key)\r\n        return node;\r\n\r\n    comparisions++;\r\n    if (key < node->key)\r\n        return tree_search(node->left, key);\r\n    else\r\n        return tree_search(node->right, key);\r\n}\r\n\r\nNode* tree_minimum(Node* node){\r\n    "]
[25.588575, "o", "Node* x = node;\r\n    \r\n    while(x->left != T_nil){\r\n        x = x->left;\r\n        read_pointers++;\r\n    } \r\n    return x;\r\n}\r\n\r\nvoid  delete_Node(int key)\r\n{\r\n    read_pointers+=2;\r\n    Node* z = tree_search(root, key);\r\n    if (z == T_nil)\r\n        return;\r\n    \r\n    Node* y = z;\r\n    Node* x = NULL;\r\n    char y_original_color = y->color;\r\n    read_pointers+=3;\r\n    if (z->left == T_nil)\r\n    {\r\n        x = z->right;\r\n        read_pointers++;\r\n        transplant(z, z->right);\r\n    }\r\n    else if(z->right == T_nil)\r\n    {\r\n        x = z->left;\r\n        read_pointers+=2;\r\n        transplant(z, z->left);\r\n    }\r\n    else\r\n    {\r\n        y = tree_minimum(z->right);\r\n        y_original_color = y->color;\r\n        x = y->right;\r\n        read_pointers+=4;\r\n        if (y->parent == z)\r\n        {\r\n            read_pointers++;\r\n            x->parent = y;\r\n        }\r\n        else\r\n        {\r\n            transplant(y, y->right);\r\n            read_pointers+=2;\r\n            y->right = z->right;\r\n            y->right->pare"]
[25.58868, "o", "nt = y;\r\n        }\r\n        transplant(z, y);\r\n        read_pointers+=2;\r\n        y->left = z->left;\r\n        y->left->parent = y;\r\n        y->color = z->color;\r\n    }\r\n    if (y_original_color == 'B')\r\n    {\r\n        delete_fixup(x);\r\n    }\r\n    free(z);\r\n}\r\n\r\nvoid  delete_fixup(Node* x)\r\n{\r\n    Node* w = NULL;\r\n    read_pointers++;\r\n    while (x != root && x->color == 'B')\r\n    {\r\n        read_pointers++;\r\n        if (x == x->parent->left)\r\n        {\r\n            read_pointers++;\r\n            w = x->parent->right;\r\n            if (w->color == 'R')\r\n            {\r\n                w->color = 'B';\r\n                x->parent->color = 'R';\r\n                left_rotate(x->parent);\r\n                w = x->parent->right;\r\n                read_pointers++;\r\n            }\r\n            if (w->left->color == 'B' && w->right->color == 'B')\r\n            {\r\n                w->color = 'R';\r\n                x = x->parent;\r\n                read_pointers++;\r\n            }\r\n            else\r\n            {\r\n                read_"]
[25.58887, "o", "pointers++;\r\n                if (w->right->color == 'B')\r\n                {\r\n                    w->left->color = 'B';\r\n                    w->color = 'R';\r\n                    right_rotate(w);\r\n                    w = x->parent->right;\r\n                    read_pointers++;\r\n                }\r\n                w->color = x->parent->color;\r\n                x->parent->color = 'B';\r\n                w->right->color = 'B';\r\n                left_rotate(x->parent);\r\n                x = root;\r\n                read_pointers++;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            read_pointers++;\r\n            w = x->parent->left;\r\n            if (w->color == 'R')\r\n            {\r\n                w->color = 'B';\r\n                x->parent->color = 'R';\r\n                right_rotate(x->parent);\r\n                w = x->parent->left;\r\n                read_pointers++;\r\n            }\r\n            if (w->left->color == 'B' && w->right->color == 'B')\r\n            {\r\n                w->color = 'R';\r\n                x ="]
[25.588932, "o", " x->parent;\r\n                read_pointers++;\r\n            }\r\n            else\r\n            {\r\n                if (w->left->color == 'B')\r\n                {\r\n                    w->right->color = 'B';\r\n                    w->color = 'R';\r\n                    left_rotate(w);\r\n                    w = x->parent->left;\r\n                    read_pointers++;\r\n                }\r\n                w->color = x->parent->color;\r\n                x->parent->color = 'B';\r\n                w->left->color = 'B';\r\n                right_rotate(x->parent);\r\n                x = root;\r\n                read_pointers++;\r\n            }\r\n        }\r\n        read_pointers++;\r\n    }\r\n    x->color = 'B';\r\n}\r\n\r\nint tree_height(Node* node)\r\n{\r\n    if (node == T_nil)\r\n    {\r\n       return -1;\r\n    }\r\n    else\r\n    {\r\n        /* compute the depth of each subtree */\r\n        int lDepth = tree_height(node->left);\r\n        int rDepth = tree_height(node->right);\r\n \r\n        /* use the larger one */ \r\n        if (lDepth > rDepth)\r\n            retur"]
[25.588964, "o", "n (lDepth + 1);\r\n        else\r\n            return (rDepth + 1);\r\n    }\r\n}\r\n\r\nvoid free_tree(Node* node)\r\n{ \r\n    if (node == T_nil)\r\n    { \r\n        return;\r\n    } \r\n    free_tree(node->left);\r\n    free_tree(node->right);\r\n\r\n    free(node);\r\n}\r\n\r\n// global variables used in `print_BST`\r\nstatic char* left_trace; // needs to be allocaded with size\r\nstatic char* right_trace; // needs to be allocaded with size\r\n\r\nvoid print_BST(Node * node, int depth,char prefix)\r\n{\r\n  if( node == T_nil ) return;\r\n  if( node->left != T_nil ){\r\n    print_BST(node->left, depth+1, '/');\r\n  }\r\n  if(prefix == '/') left_trace[depth-1]='|';\r\n  if(prefix == '\\\\') right_trace[depth-1]=' ';\r\n  if( depth==0) printf(\"-\");\r\n  if( depth>0) printf(\" \");\r\n  for(int i=0; i<depth-1; i++)\r\n    if( left_trace[i]== '|' || right_trace[i]=='|' ) \r\n    {\r\n      printf(\"| \");\r\n    } else \r\n    {\r\n      printf(\"  \");\r\n    }\r\n  if( depth>0 ) printf(\"%c-\", prefix);\r\n  printf(\"[%d|%c]\\n\", node->key, node->color);\r\n  left_trace[depth]=' ';\r\n  if( node->right "]
[25.588997, "o", "!= T_nil ){\r\n    right_trace[depth]='|';\r\n    print_BST(node->right, depth+1, '\\\\');\r\n  }\r\n}\r\nvoid fill_traces(int n)\r\n{\r\n    left_trace  = (char*)malloc((sizeof(char)*(unsigned long)n) + 1);\r\n    right_trace = (char*)malloc((sizeof(char)*(unsigned long)n) + 1);\r\n    for(int i=0; i<=n; i++)\r\n    {\r\n        left_trace[i]=' ';\r\n        right_trace[i]=' ';\r\n    }\r\n}\r\n\r\nvoid print_tree(void)\r\n{\r\n    printf(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\");\r\n    print_BST(root, 0, '-');\r\n    printf(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\");\r\n}\r\n\r\n\r\nint main(void)\r\n{\r\n    T_nil = (Node*)malloc(sizeof(Node));\r\n    T_nil->color = 'B';               \r\n    \r\n    int n, k;\r\n    double height = 0;\r\n    double sum_c = 0;\r\n    double maks_c = 0;\r\n    double sum_r = 0;\r\n    double maks_r = 0;\r\n    double sum_h = 0;\r\n    double maks_h = 0;\r\n\r\n    scanf(\"%d\", &n);\r\n    fill_traces(n);             /* Uzupełniemy trace'y do printowania drzewa */ \r\n\r\n    printf(\"insert: \\n\");\r\n    for("]
[25.589229, "o", "int i = 0; i < n; i++){\r\n      scanf(\"%d\", &k);\r\n      insert_Node(k);\r\n      printf(\"\\n\");\r\n      print_tree();\r\n      printf(\"\\n\");\r\n\r\n     if(i < 2049 ){\r\n          height = tree_height(root);\r\n      }\r\n      else if(i%50 == 0){\r\n          height = tree_height(root);\r\n      }\r\n\r\n      if(comparisions >= maks_c) maks_c = comparisions;\r\n      if(read_pointers >= maks_r) maks_r = read_pointers;\r\n      //if(curr_height >= maks_height) maks_height = curr_height;\r\n      sum_c+= comparisions;\r\n      sum_r+= read_pointers;\r\n      sum_h+= height;\r\n\r\n\r\n      //printf(\"%d, %d, %d, %d \\n\", n, comparisions, read_pointers, height );\r\n      //curr_height = 0;\r\n      comparisions = 0;\r\n      read_pointers = 0;\r\n    }\r\n\r\n    maks_h = height;\r\n\r\n    printf(\"delete: \\n\");\r\n    for(int i = 0; i < n; i++){\r\n        scanf(\"%d\", &k);\r\n        delete_Node(k);\r\n        printf(\"\\n\");\r\n        print_tree();\r\n        printf(\"\\n\");\r\n        if(i < 2049 )\r\n        {\r\n            height = tree_height(root);\r\n        }\r\n        else if(i"]
[25.589343, "o", "%50 == 0)\r\n        {\r\n          height = tree_height(root);\r\n        }\r\n\r\n        if(comparisions >= maks_c) maks_c = comparisions;\r\n        if(read_pointers >= maks_r) maks_r = read_pointers;\r\n        sum_c+= comparisions;\r\n        sum_r+= read_pointers;\r\n        sum_h+= height;\r\n\r\n        comparisions = 0;\r\n        read_pointers = 0;\r\n    }\r\n\r\n    double height_avg = sum_h/(2*n);\r\n    double comp_avg = sum_c/(2*n);\r\n    double reads_avg = sum_r/(2*n);\r\n\r\n    //printf(\"size_n,  comp_avg,  comp_maks, reads_avg, reads_maks, h_avg,   h_final   h_maks \\n\");\r\n    printf(\"%d, %f, %f, %f, %f, %f, %f, %f \\n\", n, comp_avg, maks_c, reads_avg, maks_r, height_avg, height, maks_h);\r\n\r\n\r\n    free_tree(root);\r\n    free(T_nil);\r\n    free(left_trace);\r\n    free(right_trace);\r\n    return 0;\r\n}\r\n\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab4\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab4\u001b[00m$ "]
[44.627691, "o", "valgrind --leak-check=yes --track-origins=yes ./generator 10 |  ./rbtree"]
[45.741681, "o", "\b\u001b[K"]
[45.925179, "o", "\b\u001b[K"]
[46.089568, "o", "\b\u001b[K"]
[46.244299, "o", "\b\u001b[K"]
[46.418917, "o", "\b\u001b[K"]
[46.791507, "o", "\b\u001b[K"]
[47.53165, "o", "b"]
[47.786932, "o", "s"]
[48.030883, "o", "t"]
[49.022178, "o", "\r\n"]
[49.040352, "o", "==31427== Memcheck, a memory error detector\r\n==31427== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==31427== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==31427== Command: ./generator 10\r\n==31427== \r\n"]
[49.890436, "o", "inserting: \r\n"]
[49.905125, "o", "\r\n-[17]\r\n\r\n"]
[49.9054, "o", "\r\n /-[5]\r\n-[17]\r\n\r\n\r\n /-[5]\r\n | \\-[6]\r\n-[17]\r\n\r\n\r\n /-[5]\r\n | \\-[6]\r\n |   \\-[14]\r\n-[17]\r\n\r\n\r\n /-[5]\r\n | \\-[6]\r\n |   \\-[14]\r\n-[17]\r\n \\-[18]\r\n\r\n\r\n   /-[1]\r\n /-[5]\r\n | \\-[6]\r\n |   \\-[14]\r\n-[17]\r\n \\-[18]\r\n\r\n\r\n   /-[1]\r\n /-[5]\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[14]\r\n-[17]\r\n \\-[18]\r\n\r\n\r\n   /-[1]\r\n   | \\-[3]\r\n /-[5]\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[14]\r\n-[17]\r\n \\-[18]\r\n\r\n\r\n   /-[1]\r\n   | \\-[3]\r\n /-[5]\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[14]\r\n |     \\-[15]\r\n-[17]\r\n \\-[18]\r\n\r\n\r\n   /-[1]\r\n   | \\-[3]\r\n /-[5]\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[14]\r\n |     \\-[15]\r\n |       \\-[16]\r\n-[17]\r\n \\-[18]\r\n\r\ndeleting: \r\n"]
[49.906017, "o", "\r\n   /-[1]\r\n"]
[49.906114, "o", "   | \\-[3]\r\n /-[5]\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[14]\r\n |     \\-[15]\r\n |       \\-[16]\r\n-[17]\r\n \\-[18]\r\n\r\n"]
[49.906186, "o", "\r\n   /-[1]\r\n   | \\-[3]\r\n /-[5]\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[14]\r\n |     \\-[15]\r\n |       \\-[16]\r\n-[17]\r\n \\-[18]\r\n\r\n\r\n   /-[1]\r\n"]
[49.906255, "o", "   | \\-[3]\r\n /-[5]\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[14]\r\n |     \\-[15]\r\n |       \\-[16]\r\n-[17]\r\n \\-[18]\r\n\r\n\r\n   /-[1]\r\n /-[5]\r\n | \\-[6]\r\n"]
[49.906322, "o", " |   | /-[10]\r\n |   \\-[14]\r\n |     \\-[15]\r\n |       \\-[16]\r\n-[17]\r\n \\-[18]\r\n\r\n\r\n   /-[1]\r\n /-[5]\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[14]\r\n |     \\-[15]\r\n |       \\-[16]"]
[49.90638, "o", "\r\n-[17]\r\n\r\n\r\n   /-[1]\r\n /-[5]\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[15]\r\n |     \\-[16]\r\n-[17]\r\n\r\n\r\n   /-[1]\r\n /-[5]"]
[49.906436, "o", "\r\n | \\-[6]\r\n |   | /-[10]\r\n |   \\-[15]\r\n |     \\-[16]\r\n-[17]\r\n\r\n\r\n /-[1]\r\n-[5]\r\n \\-[6]\r\n   | /-[10]\r\n"]
[49.906499, "o", "   \\-[15]\r\n     \\-[16]\r\n\r\n\r\n /-[1]\r\n-[5]\r\n \\-[6]\r\n   | /-[10]\r\n   \\-[15]\r\n     \\-[16]\r\n\r\n\r\n /-[1]\r\n-[5]\r\n \\-[6]\r\n   | /-[10]\r\n"]
[49.906582, "o", "   \\-[15]\r\n     \\-[16]\r\n\r\n10, 4.900000, 11.000000, 3.350000, 11.000000, 4.050000, 3.000000, 6.000000 \r\n"]
[49.930839, "o", "==31427== \r\n==31427== HEAP SUMMARY:\r\n==31427==     in use at exit: 0 bytes in 0 blocks\r\n==31427==   total heap usage: 2 allocs, 2 frees, 76,800 bytes allocated\r\n==31427== \r\n==31427== All heap blocks were freed -- no leaks are possible\r\n==31427== \r\n==31427== For lists of detected and suppressed errors, rerun with: -s\r\n==31427== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\r\n"]
[49.942435, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab4\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab4\u001b[00m$ "]
[51.611621, "o", "valgrind --leak-check=yes --track-origins=yes ./generator 10 |  ./bst"]
[52.521922, "o", "\b\u001b[K"]
[52.700458, "o", "\b\u001b[K"]
[52.906133, "o", "\b\u001b[K"]
[53.53771, "o", "s"]
[53.815745, "o", "p"]
[54.004941, "o", "l"]
[54.154342, "o", "a"]
[54.342144, "o", "y"]
[55.10524, "o", "\r\n"]
[55.123035, "o", "==31431== Memcheck, a memory error detector\r\n==31431== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==31431== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==31431== Command: ./generator 10\r\n==31431== \r\n"]
[55.946807, "o", "inserting: \r\n"]
[55.961328, "o", "\r\n-[19]\r\n\r\n"]
[55.961615, "o", "\r\n-[1]\r\n \\-[19]\r\n\r\n"]
[55.961686, "o", "\r\n-[0]\r\n \\-[1]\r\n   \\-[19]\r\n\r\n\r\n   /-[0]\r\n /-[1]\r\n-[12]\r\n \\-[19]\r\n\r\n"]
[55.96183, "o", "\r\n   /-[0]\r\n /-[1]\r\n-[11]\r\n \\-[12]\r\n   \\-[19]\r\n\r\n\r\n   /-[0]\r\n /-[1]\r\n-[7]\r\n"]
[55.96189, "o", " \\-[11]\r\n   \\-[12]\r\n     \\-[19]\r\n\r\n\r\n     /-[0]\r\n   /-[1]\r\n /-[7]\r\n-[10]\r\n \\-[11]\r\n   \\-[12]\r\n     \\-[19]\r\n\r\n\r\n         /-[0]\r\n       /-[1]\r\n     /-[7]\r\n   /-[10]\r\n /-[11]\r\n | \\-[12]\r\n-[16]\r\n \\-[19]\r\n\r\n\r\n           /-[0]\r\n         /-[1]\r\n       /-[7]\r\n     /-[10]\r\n   /-[11]\r\n /-[12]\r\n-[13]\r\n \\-[16]\r\n   \\-[19]\r\n\r\n\r\n   /-[0]\r\n /-[1]\r\n-[2]\r\n |   /-[7]\r\n"]
[55.961946, "o", " | /-[10]\r\n | | \\-[11]\r\n \\-[12]\r\n   \\-[13]\r\n     \\-[16]\r\n       \\-[19]\r\n\r\ndeleting: \r\n"]
[55.962435, "o", "\r\n       /-[0]\r\n     /-[1]\r\n   /-[2]\r\n   | | /-[7]\r\n"]
[55.962624, "o", "   | \\-[10]\r\n   |   \\-[11]\r\n /-[12]\r\n-[13]\r\n \\-[19]\r\n\r\n\r\n       /-[0]\r\n     /-[1]\r\n   /-[2]\r\n   | | /-[7]\r\n   | \\-[10]\r\n   |   \\-[11]\r\n /-[12]\r\n-[13]\r\n\r\n\r\n     /-[0]\r\n   /-[1]\r\n /-[2]\r\n | | /-[7]\r\n | \\-[10]\r\n |   \\-[11]\r\n-[12]\r\n\r\n\r\n     /-[0]\r\n   /-[1]\r\n /-[2]\r\n-[7]\r\n | /-[10]\r\n | | \\-[11]\r\n \\-[12]\r\n\r\n\r\n       /-[0]\r\n"]
[55.962671, "o", "     /-[1]\r\n   /-[2]\r\n /-[7]\r\n | \\-[10]\r\n |   \\-[11]\r\n-[12]\r\n\r\n\r\n       /-[0]\r\n     /-[1]\r\n"]
[55.962732, "o", "   /-[2]\r\n /-[7]\r\n | \\-[10]\r\n |   \\-[11]\r\n-[12]\r\n\r\n\r\n       /-[0]\r\n     /-[1]\r\n   /-[2]\r\n /-[7]\r\n-[10]\r\n | /-[11]\r\n \\-[12]\r\n"]
[55.962842, "o", "\r\n"]
[55.962866, "o", "\r\n-[0]\r\n | /-[2]\r\n \\-[7]\r\n   \\-[10]\r\n     | /-[11]\r\n     \\-[12]\r\n\r\n\r\n   /-[0]\r\n   | \\-[2]\r\n /-[7]\r\n | \\-[10]\r\n |   \\-[11]\r\n-[12]\r\n\r\n\r\n   /-[0]\r\n   | \\-[2]\r\n /-[7]\r\n-[10]\r\n | /-[11]\r\n \\-[12]\r\n\r\n"]
[55.962939, "o", "10, 7.050000, 13.000000, 14.900000, 32.000000, 3.200000, 3.000000, 4.000000 \r\n"]
[55.987061, "o", "==31431== \r\n==31431== HEAP SUMMARY:\r\n==31431==     in use at exit: 0 bytes in 0 blocks\r\n==31431==   total heap usage: 2 allocs, 2 frees, 76,800 bytes allocated\r\n==31431== \r\n==31431== All heap blocks were freed -- no leaks are possible\r\n==31431== \r\n==31431== For lists of detected and suppressed errors, rerun with: -s\r\n==31431== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\r\n"]
[56.001673, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab4\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab4\u001b[00m$ "]
[57.932635, "o", "valgrind --leak-check=yes --track-origins=yes ./generator 10 |  ./splay"]
[58.798886, "o", "\b\u001b[K"]
[58.978237, "o", "\b\u001b[K"]
[59.147324, "o", "\b\u001b[K"]
[59.326772, "o", "\b\u001b[K"]
[60.108308, "o", "\b\u001b[K"]
[60.600405, "o", "r"]
[60.87946, "o", "b"]
[61.187786, "o", "t"]
[61.432995, "o", "r"]
[61.611247, "o", "e"]
[61.824253, "o", "e"]
[65.837991, "o", "\r\n"]
[65.854495, "o", "==31436== Memcheck, a memory error detector\r\n==31436== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\r\n==31436== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\r\n==31436== Command: ./generator 10\r\n==31436== \r\n"]
[66.724357, "o", "insert: \r\n"]
[66.737694, "o", "\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n"]
[66.737929, "o", "\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n /-[12|R]\r\n-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n /-[12|R]\r\n-[13|B]\r\n \\-[19|R]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|R]\r\n /-[12|B]\r\n-[13|B]\r\n \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|R]\r\n /-[3|B]\r\n | \\-[12|R]\r\n-[13|B]\r\n \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[11|R]\r\n | \\-[12|B]\r\n-[13|B]\r\n \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[11|R]\r\n | \\-[12|B]\r\n-[13|B]\r\n | /-[17|R]\r\n \\-[19|B]\r\n~~~~~~~"]
[66.737998, "o", "~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[17|R]\r\n \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[16|R]\r\n \\-[17|B]\r\n   \\-[19|R]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   | /-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\ndelete: \r\n"]
[66.738447, "o", "\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   | /-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n"]
[66.738558, "o", "\r\n"]
[66.738657, "o", "~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   | /-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   | /-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~"]
[66.7387, "o", "~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[3|R]\r\n | | /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n"]
[66.738756, "o", "~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[5|R]\r\n | \\-[11|B]\r\n |   \\-[12|R]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[11|R]\r\n | \\-[12|B]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[11|R]\r\n | \\-[12|B]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BST ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n   /-[2|B]\r\n /-[11|R]\r\n | \\-[12|B]\r\n-[13|B]\r\n | /-[16|B]\r\n \\-[17|R]\r\n   \\-[19|B]\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n10, 4.700000, 9.000000, 9.600000, 22.000000, 2.400000, 2.000000, 3.000000 \r\n"]
[66.766968, "o", "==31436== \r\n==31436== HEAP SUMMARY:\r\n==31436==     in use at exit: 0 bytes in 0 blocks\r\n==31436==   total heap usage: 2 allocs, 2 frees, 76,800 bytes allocated\r\n==31436== \r\n==31436== All heap blocks were freed -- no leaks are possible\r\n==31436== \r\n==31436== For lists of detected and suppressed errors, rerun with: -s\r\n==31436== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\r\n"]
[66.779521, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab4\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab4\u001b[00m$ "]
[71.955898, "o", "l"]
[72.290687, "o", "s"]
[74.170932, "o", "\r\n"]
[74.173505, "o", "asco_gene.cpp   \u001b[0m\u001b[01;32mbst\u001b[0m    bst.h      generator_tests.cpp  RBTree.c  red_black_tree.h  Splay.c  testy_bst_sorted.sh    \u001b[01;32mtesty_splay_sorted.sh\u001b[0m\r\n\u001b[01;32masco_generator\u001b[0m  BST.c  \u001b[01;32mgenerator\u001b[0m  \u001b[01;32mrbtree\u001b[0m               records   \u001b[01;32msplay\u001b[0m             splay.h  \u001b[01;32mtesty_bst_unsorted.sh\u001b[0m  \u001b[01;32mtesty_splay_unsorted.sh\u001b[0m\r\n"]
[74.174321, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab4\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab4\u001b[00m$ "]
[75.281248, "o", "e"]
[75.654088, "o", "x"]
[76.112427, "o", "i"]
[76.560392, "o", "t"]
[80.368894, "o", "\b\u001b[K"]
[80.543583, "o", "\b\u001b[K"]
[80.717081, "o", "\b\u001b[K"]
[80.925927, "o", "\b\u001b[K"]
[81.66824, "o", "c"]
[82.275362, "o", "\b\u001b[K"]
[82.682093, "o", "\u0007"]
[84.88383, "o", "e"]
[85.286899, "o", "x"]
[85.506212, "o", "i"]
[85.828641, "o", "t"]
[86.362469, "o", "\r\n"]
[86.362879, "o", "exit\r\n"]
