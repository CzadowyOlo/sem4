{"version": 2, "width": 158, "height": 41, "timestamp": 1651494354, "env": {"SHELL": "/bin/bash", "TERM": "xterm-256color"}}
[0.037559, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702\u001b[00m$ "]
[1.080824, "o", "l"]
[1.409483, "o", "s"]
[1.858514, "o", "\r\n"]
[1.860844, "o", "\u001b[0m\u001b[01;34mlab1\u001b[0m  \u001b[01;34mlab2\u001b[0m  \u001b[01;34mlab3\u001b[0m  rekords  rekordy\r\n"]
[1.861283, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702\u001b[00m$ "]
[4.163604, "o", "c"]
[4.351571, "o", "d"]
[4.625927, "o", " "]
[5.004929, "o", "l"]
[5.190827, "o", "a"]
[5.364581, "o", "b"]
[5.703357, "o", "3"]
[5.982579, "o", "\r\n"]
[5.982853, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[8.646289, "o", "l"]
[8.850118, "o", "s"]
[9.054943, "o", "\r\n"]
[9.057237, "o", "ascender.cpp        BS_poczatek_m100.txt      DPQSUpgrade.cpp      QSU_vs_QS_AVG.ods     RandomSelect.cpp  zad3_testy.sh\r\nBinarySearch.cpp    BS_POCZ_SROD_KON_LOS.ods  generator_tests.cpp  QS_VS_QSU_WORST.ods   Select_1.cpp      zad4_testy.sh\r\nBS_koniec_m100.txt  BS_srodek_m100.txt        QS_AVG_m100.txt      QuickSort.cpp         Select_zad3.cpp   zad5_testy.sh\r\nBS_losowy_m100.txt  descender.cpp             QSU_AVG_m100.txt     QuickSortUpgrade.cpp  zad2_testy.sh\r\n"]
[9.057684, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[15.349355, "o", "c"]
[15.65299, "o", "a"]
[15.857372, "o", "t"]
[16.081984, "o", " "]
[17.268843, "o", "B"]
[17.543082, "o", "i"]
[17.798024, "o", "n"]
[17.957452, "o", "a"]
[18.162456, "o", "r"]
[18.396568, "o", "y"]
[18.924695, "o", "S"]
[19.682799, "o", "e"]
[20.551125, "o", "a"]
[20.864796, "o", "r"]
[21.229544, "o", "c"]
[21.453372, "o", "h"]
[22.256422, "o", "."]
[22.576084, "o", "c"]
[22.815634, "o", "p"]
[22.989595, "o", "p"]
[23.912194, "o", "\r\n"]
[23.913847, "o", "// C++ implementation of worst case linear time algorithm\r\n// to find k'th smallest element\r\n#include<iostream>\r\n#include<algorithm>\r\n#include<climits>\r\n\r\nusing namespace std;\r\n\r\nlong int porownania = 0;\r\nlong int przestawienia = 0;\r\n\r\nvoid wypisz_tablice(int tab[], int n)\r\n{\r\n    cout << \" {\";\r\n    for (int i = 0; i < n - 1; ++i)\r\n    {\r\n        cout << tab[i] << \", \";\r\n\t\tif((i+1)%5 == 0) cout<<\"|\";\r\n    }\r\n    cout << tab[n - 1] << \"}\" << endl;\r\n}\r\n/**\r\n * @brief \r\n * \r\n * @param tab = tablica w ktorej szukamy elementu v \r\n * @param l = index pierwszego elementu tablicy\r\n * @param r = index ostatnigo elementu tablicy\r\n * @param v = element ktorego szukamy\r\n * @return int 1 jesli element v jest w tab[], w przciwnym razie 0\r\n */\r\n\r\nint binarySearch(int tab[], int l, int r, int v){\r\n\r\n        int n = r-l+1;\r\n        \r\n        if(v == tab[l+(n/2)]){\r\n            porownania++;\r\n            return 1;\r\n        }\r\n        else if(l>=r){\r\n            return 0;\r\n        }\r\n        else if(v < tab[l+n/2]){\r\n          "]
[23.91402, "o", "  porownania+=2;\r\n            return binarySearch(tab, l, l + n/2 - 1, v);\r\n        }\r\n        else{\r\n            porownania+=2;\r\n            return binarySearch(tab, l + n/2 + 1, r, v);\r\n        }\r\n\r\n// [1,3,5,|7|,13,15,19] n = 7 -> tab[n/2] = 7 niech v = 19\r\n}\r\n\r\nvoid merge_over50(int tab[], int l, int m, int r)\r\n{\r\n\r\n    int i = l;\r\n    int j = m + 1;\r\n    int k = l;\r\n\r\n    int tempTab[r];\r\n\r\n    while (i <= m && j <= r)\r\n    {\r\n        if (tab[i] <= tab[j])\r\n        {\r\n            tempTab[k] = tab[i];\r\n            i++;\r\n            k++;\r\n        }\r\n        else\r\n        {\r\n            tempTab[k] = tab[j];\r\n            j++;\r\n            k++;\r\n        }\r\n    }\r\n\r\n    while (i <= m)\r\n    {\r\n        tempTab[k] = tab[i];\r\n        i++;\r\n        k++;\r\n    }\r\n    while (j <= r)\r\n    {\r\n        tempTab[k] = tab[j];\r\n        j++;\r\n        k++;\r\n    }\r\n\r\n    for (int p = l; p <= r; ++p)\r\n    {\r\n        tab[p] = tempTab[p];\r\n    }\r\n}\r\n\r\nvoid mergeSort_over50(int tab[], int l, int r)\r\n{\r\n    if (l < r)\r\n    {\r\n       "]
[23.914137, "o", " int m = (l + r) / 2;\r\n        mergeSort_over50(tab, l, m);\r\n        mergeSort_over50(tab, m + 1, r);\r\n        merge_over50(tab, l, m, r);\r\n    }\r\n}\r\n\r\n// Driver program to test above methods\r\nint main(int argc, char *argv[])\r\n{\r\n    int where = stoi(argv[1]);\r\n\tint n;  // wielkosc tablicy \r\n    int x;  // kolejne elementy tablicy\r\n    cin >> n;\r\n    int tab[n];\r\n    int v = 1; // = stoi(argv[1]); \r\n    cin >> v; // losowy indeks z jakiegos zakresu, np 5, czyli szósty element tablicy\r\n\r\n    for (int p = 0; p < n; p++)\r\n    {\r\n        cin >> x;\r\n        tab[p] = x;\r\n    }\r\n\r\n    // srand(time(NULL));\r\n\r\n    \r\n\r\n    mergeSort_over50(tab,0,n-1);\r\n\r\n    int val = tab[v-1];\r\n    int odp;\r\n    // wypisz_tablice(tab,n);\r\n    // cout << \"Czy tab zawiera \" << val << \"?\" << endl;\r\n    // cout << \"Odp: \" << binarySearch(tab,0,n-1,val) << endl;\r\n    srand(time(NULL));\r\n    const clock_t begin_time = clock(); // time\r\n\r\n    switch(where){\r\n        case 0:\r\n            odp = binarySearch(tab,0,n-1,val);\r\n            break"]
[23.914268, "o", ";\r\n        case 1:\r\n            //cout<<\"poczo\"<<endl;\r\n            v =  rand()%(n/10); // v == (0, n/10)\r\n            //cout<<v<<endl;\r\n            val = tab[v];\r\n            //cout<<val<<endl;\r\n            odp = binarySearch(tab,0,n-1,val);\r\n            break;\r\n        case 2:\r\n            //cout<<\"konco\"<<endl;\r\n            v = n - 1 - (rand()%(n/10)); // v == (n-1-n/10, n-1)\r\n            //cout<<v<<endl;\r\n            val = tab[v];\r\n            //cout<<val<<endl;\r\n            odp = binarySearch(tab,0,n-1,val);\r\n            break;\r\n        case 3:\r\n            v = n/2 - n/20 + rand()%(n/10);\r\n            val = tab[v];\r\n            odp = binarySearch(tab,0,n-1,val);\r\n            break;\r\n\r\n        default:\r\n            break;    \r\n\r\n    }\r\n    \r\n\r\n    const clock_t end_time = clock(); // time\r\n    float dur = float( end_time - begin_time ) /  CLOCKS_PER_SEC;\r\n\r\n    cout << n << \" \"<<porownania<<\" \"<<dur*1000<<endl;\r\n    //cout<<odp<<endl;\r\n    \r\n    \r\n\treturn 0;\r\n}\r\n"]
[23.914368, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[25.822971, "o", "\u0007"]
[26.446538, "o", "cat BinarySearch.cpp"]
[26.947278, "o", "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bls\u001b[K"]
[26.977854, "o", "\b\bcd lab3"]
[27.009071, "o", "\b\b\b\b\b\b\bls\u001b[K"]
[27.463976, "o", "\b\bcd lab3"]
[27.712938, "o", "\b\b\b\b\b\b\bls\u001b[K"]
[28.093087, "o", "\b\bcat BinarySearch.cpp"]
[28.531451, "o", "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\u001b[K"]
[30.83065, "o", "cat BinarySearch.cpp"]
[31.718531, "o", "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\u001b[K"]
[32.521267, "o", "l"]
[33.304267, "o", "s"]
[33.758097, "o", "\r\n"]
[33.760513, "o", "ascender.cpp        BS_poczatek_m100.txt      DPQSUpgrade.cpp      QSU_vs_QS_AVG.ods     RandomSelect.cpp  zad3_testy.sh\r\nBinarySearch.cpp    BS_POCZ_SROD_KON_LOS.ods  generator_tests.cpp  QS_VS_QSU_WORST.ods   Select_1.cpp      zad4_testy.sh\r\nBS_koniec_m100.txt  BS_srodek_m100.txt        QS_AVG_m100.txt      QuickSort.cpp         Select_zad3.cpp   zad5_testy.sh\r\nBS_losowy_m100.txt  descender.cpp             QSU_AVG_m100.txt     QuickSortUpgrade.cpp  zad2_testy.sh\r\n"]
[33.761017, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[47.52459, "o", "c"]
[47.82939, "o", "a"]
[48.02387, "o", "t"]
[48.602225, "o", " "]
[58.463492, "o", "Q"]
[59.11736, "o", "u"]
[59.346378, "o", "i"]
[59.875383, "o", "c"]
[60.773349, "o", "k"]
[61.281381, "o", "S"]
[61.69126, "o", "o"]
[62.279279, "o", "r"]
[62.474452, "o", "t"]
[63.377064, "o", "U"]
[63.705735, "o", "p"]
[64.086444, "o", "g"]
[64.369467, "o", "r"]
[64.514648, "o", "a"]
[64.643633, "o", "d"]
[64.848671, "o", "e"]
[65.581585, "o", "."]
[66.03687, "o", "c"]
[66.370101, "o", "p"]
[66.564106, "o", "p"]
[67.841325, "o", "\r\n"]
[67.842978, "o", "//QuickSort\r\n\r\n#include <iostream>\r\n#include <stdlib.h> \r\n// #include <chrono>\r\n#include<climits>\r\n\r\nusing namespace std;\r\n\r\nlong int comparisions = 0;\r\nlong int shifts = 0;\r\n\r\nint partition(int arr[], int l, int r, int x);\r\nint partitionBig(int arr[], int l, int r, int x);\r\n\r\n\r\nvoid printer (int tab[], int n){\r\n    cout<<\"{\";\r\n    for(int i = 0; i < n; i++){\r\n        printf(\"%d, \", tab[i]);\r\n    }\r\n    cout<<\"}\\n\";\r\n    return;\r\n}\r\n\r\nint myCeil(int x, int y){\r\n    return (x%y == 0)? (x/y) : (x/y + 1);\r\n}\r\nint myFloor(int x, int y){\r\n    return (x%y == 0)? (x/y - 1) : (x/y);\r\n}\r\n\r\nvoid insertionSort(int arr[], int n)\r\n{\r\n    int i, key, j;\r\n    for (i = 1; i < n; i++)\r\n    {\r\n        key = arr[i];\r\n        j = i - 1;\r\n \r\n        /* Move elements of arr[0..i-1], that are\r\n        greater than key, to one position ahead\r\n        of their current position */\r\n        while (j >= 0 && arr[j] > key)\r\n        {\r\n            shifts++;\r\n\t\t\tcomparisions++;\r\n\t\t\tarr[j + 1] = arr[j];\r\n            j = j - 1;\r\n        }\r\n\t"]
[67.843229, "o", "\tshifts++;\r\n        arr[j + 1] = key;\r\n    }\r\n}\r\n\r\n// A simple function to find median of arr[]. This is called\r\n// only for an array of size 5 in this program.\r\nint findMedian(int arr[], int n)\r\n{\r\n\t//sort(arr, arr+n); // Sort the array\r\n\tinsertionSort(arr, n);\r\n\treturn arr[n/2]; // Return middle element\r\n}\r\n\r\n\r\n// Returns k'th smallest element in arr[l..r] in worst case\r\n// linear time. ASSUMPTION: ALL ELEMENTS IN ARR[] ARE DISTINCT\r\nint Select(int arr[], int l, int r, int k)\r\n{\r\n\t// If k is smaller than number of elements in array\r\n\tif (k > 0 && k <= r - l + 1)\r\n\t{\r\n\t\tint n = r-l+1; // Number of elements in arr[l..r]\r\n\r\n\t\t// Divide arr[] in groups of size 5, calculate median\r\n\t\t// of every group and store it in median[] array.\r\n\t\tint i, median[(n+4)/5]; // There will be floor((n+4)/5) groups;\r\n\t\tfor (i=0; i<n/5; i++)\r\n\t\t\tmedian[i] = findMedian(arr+l+i*5, 5);\r\n\t\tif (i*5 < n) //For last group with less than 5 elements\r\n\t\t{\r\n\t\t\tmedian[i] = findMedian(arr+l+i*5, n%5);\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\t// Find median of all m"]
[67.843361, "o", "edians using recursive call.\r\n\t\t// If median[] has only one element, then no need\r\n\t\t// of recursive call\r\n\t\tint medOfMed = (i == 1)? median[i-1]:\r\n\t\t\t\t\t\t\t\tSelect(median, 0, i-1, i/2);\r\n\r\n\t\t// Partition the array around a random element and\r\n\t\t// get position of pivot element in sorted array\r\n\t\tint pos = partition(arr, l, r, medOfMed);\r\n\r\n\t\t// If position is same as k\r\n\t\tcomparisions++;\r\n\t\tif (pos-l == k-1)\r\n\t\t\treturn arr[pos];\r\n\t\t\r\n\t\tcomparisions++;\r\n\t\tif (pos-l > k-1) // If position is more, recur for left\r\n\t\t\treturn Select(arr, l, pos-1, k);\r\n\r\n\t\t// Else recur for right subarray\r\n\t\treturn Select(arr, pos+1, r, k-pos+l-1);\r\n\t}\r\n\r\n\t// If k is more than number of elements in array\r\n\treturn INT_MAX;\r\n}\r\n\r\nint partition(int arr[], int l, int r, int x)\r\n{\r\n\t// Search for x in arr[l..r] and move it to end\r\n\tint i;\r\n\tfor (i=l; i<r; i++){\r\n\t\tcomparisions++;\r\n\t\tif (arr[i] == x)\r\n\t\tbreak;\r\n\t}\r\n\tshifts++;\r\n\tswap(arr[i], arr[r]);\r\n\r\n\t// Standard partition algorithm\r\n\ti = l;\r\n\tfor (int j = l; j <= r - 1; j++)\r\n\t{\r\n\t\tcom"]
[67.843481, "o", "parisions++;\r\n\t\tif (arr[j] <= x)\r\n\t\t{\r\n\t\t\tshifts++;\r\n\t\t\tswap(arr[i], arr[j]);\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\tcomparisions++;\r\n\tswap(arr[i], arr[r]);\r\n\treturn i;\r\n}\r\n\r\nint partitionBig(int arr[], int l, int r, int x)\r\n{\r\n\t// Search for x in arr[l..r] and move it to end\r\n\tint i;\r\n\tfor (i=l; i<r; i++){\r\n\t\tcomparisions++;\r\n\t\tif (arr[i] == x)\r\n\t\tbreak;\r\n\t}\r\n\tshifts++;\r\n\tswap(arr[i], arr[r]);\r\n\r\n\t// Standard partition algorithm\r\n\ti = l;\r\n\tfor (int j = l; j <= r - 1; j++)\r\n\t{\r\n\t\tcomparisions++;\r\n\t\tif (arr[j] <= x)\r\n\t\t{\r\n\t\t\tshifts++;\r\n\t\t\tswap(arr[i], arr[j]);\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\tcomparisions++;\r\n\tswap(arr[i], arr[r]);\r\n\treturn i;\r\n}\r\n\r\n\r\nvoid quickSort(int tab[], int p, int q, int n){\r\n    if (p < q){\r\n        int pivot = Select(tab, p, q, myFloor(q - p + 1, 2));\r\n        int r = partition(tab, p, q, pivot);\r\n        quickSort(tab, p, r - 1, n);\r\n        quickSort(tab, r + 1, q, n);\r\n    }\r\n}\r\n\r\n\r\nvoid quickSortBig(int tab[], int p, int q, int n){\r\n    if (p < q){\r\n        int pivot = Select(tab, p, q, myFloor(q - p + 1, 2));\r\n"]
[67.843572, "o", "        int r = partitionBig(tab, p, q, pivot);\r\n        quickSortBig(tab, p, r - 1, n);\r\n        quickSortBig(tab, r+ 1, q, n);\r\n    }\r\n}\r\n\r\nint main(){\r\n    \r\n    int n, nulle;\r\n    cin >> n;\r\n    // cin >> nulle;\r\n    int mytab[n];\r\n\r\n    \r\n\r\n    for (int i = 0; i < n; i++){\r\n        cin >> mytab[i];\r\n    }\r\n\r\n    if(n <= 50){\r\n        printf(\"Array of %d-elements before sorting: \\n\", n);\r\n        printer(mytab, n);\r\n    }\r\n    const clock_t begin_time = clock();\r\n    \r\n    if(n<=50){\r\n        quickSort(mytab, 0, n-1, n);\r\n    }\r\n    else{\r\n        quickSortBig(mytab, 0, n-1, n);\r\n    }\r\n    \r\n    \r\n    const clock_t end_time = clock();\r\n    \r\n    float dur = float( end_time - begin_time ) /  CLOCKS_PER_SEC;\r\n\r\n    if(n <= 50){\r\n        printf(\"Array of %d-elements after sorting: \\n\", n);\r\n        printer(mytab, n);\r\n        \r\n    }\r\n    else{\r\n        //printf(\"size of tab: %d\\n comparisions: %ld\\n       shifts: %ld \\ntime(milli_s): %f \\n\", n, comparisions, shifts, dur*1000);\r\n        cout<<endl<<n<<\" \"<<"]
[67.843647, "o", "comparisions<<\" \"<<shifts<<\" \"<<dur*1000<<\" \";\r\n\r\n    }\r\n}\r\n\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[69.861249, "o", "l"]
[70.374971, "o", "s"]
[70.639273, "o", "\r\n"]
[70.641551, "o", "ascender.cpp        BS_poczatek_m100.txt      DPQSUpgrade.cpp      QSU_vs_QS_AVG.ods     RandomSelect.cpp  zad3_testy.sh\r\nBinarySearch.cpp    BS_POCZ_SROD_KON_LOS.ods  generator_tests.cpp  QS_VS_QSU_WORST.ods   Select_1.cpp      zad4_testy.sh\r\nBS_koniec_m100.txt  BS_srodek_m100.txt        QS_AVG_m100.txt      QuickSort.cpp         Select_zad3.cpp   zad5_testy.sh\r\nBS_losowy_m100.txt  descender.cpp             QSU_AVG_m100.txt     QuickSortUpgrade.cpp  zad2_testy.sh\r\n"]
[70.642056, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[73.692599, "o", "c"]
[73.941979, "o", "a"]
[74.146228, "o", "t"]
[74.355861, "o", " "]
[75.005125, "o", "S"]
[75.31318, "o", "e"]
[75.937204, "o", "l"]
[76.167172, "o", "e"]
[76.476021, "o", "c"]
[76.990436, "o", "t"]
[77.987744, "o", "_"]
[78.585981, "o", "z"]
[78.816317, "o", "a"]
[78.970601, "o", "d"]
[79.303731, "o", "3"]
[80.27156, "o", "."]
[80.680511, "o", "c"]
[80.890074, "o", "p"]
[81.050728, "o", "p"]
[81.833494, "o", "\r\n"]
[81.835169, "o", "// C++ implementation of worst case linear time algorithm\r\n// to find k'th smallest element\r\n#include<iostream>\r\n#include<algorithm>\r\n#include<climits>\r\n\r\nusing namespace std;\r\n\r\nlong int porownania = 0;\r\nlong int przestawienia = 0;\r\n\r\nvoid wypisz_tablice(int tab[], int n, int subarray_size)\r\n{\r\n    cout << \" {\";\r\n    for (int i = 0; i < n - 1; ++i)\r\n    {\r\n        cout << tab[i] << \", \";\r\n\t\tif((i+1)%subarray_size == 0) cout<<\"|\";\r\n    }\r\n    cout << tab[n - 1] << \"}\" << endl;\r\n}\r\n\r\nint partition(int arr[], int l, int r, int k);\r\n\r\nvoid insertionSort(int arr[], int n)\r\n{\r\n    int i, key, j;\r\n    for (i = 1; i < n; i++)\r\n    {\r\n        key = arr[i];\r\n        j = i - 1;\r\n \r\n        /* Move elements of arr[0..i-1], that are\r\n        greater than key, to one position ahead\r\n        of their current position */\r\n        while (j >= 0 && arr[j] > key)\r\n        {\r\n            przestawienia++;\r\n\t\t\tporownania++;\r\n\t\t\tarr[j + 1] = arr[j];\r\n            j = j - 1;\r\n        }\r\n\t\tprzestawienia++;\r\n        arr[j + 1] = key;\r"]
[81.835346, "o", "\n    }\r\n}\r\n\r\n// A simple function to find median of arr[]. This is called\r\n// only for an array of size 5 in this program.\r\nint findMedian(int arr[], int n)\r\n{\r\n\t//sort(arr, arr+n); // Sort the array\r\n\tinsertionSort(arr, n);\r\n\treturn arr[n/2]; // Return middle element\r\n}\r\n\r\n\r\n// Returns k'th smallest element in arr[l..r] in worst case\r\n// linear time. ASSUMPTION: ALL ELEMENTS IN ARR[] ARE DISTINCT\r\nint SelectDiffSubarrays(int arr[], int l, int r, int k, int subarray_size)\r\n{\r\n\t// If k is smaller than number of elements in array\r\n\tif (k > 0 && k <= r - l + 1)\r\n\t{\r\n\t\tint n = r-l+1; // Number of elements in arr[l..r]\r\n\r\n\t\t// Divide arr[] in groups of size 5, calculate median\r\n\t\t// of every group and store it in median[] array.\r\n\t\tint i, median[(n+(subarray_size-1))/subarray_size]; // There will be floor((n+4)/5) groups;\r\n\t\tfor (i=0; i<n/subarray_size; i++){\r\n\t\t\tmedian[i] = findMedian(arr+l+i*subarray_size, subarray_size);\r\n            // wypisz_tablice(arr,n,subarray_size);\r\n        }\r\n\t\tif (i*subarray_size < n)"]
[81.835469, "o", " //For last group with less than 5 elements\r\n\t\t{\r\n\t\t\tmedian[i] = findMedian(arr+l+i*subarray_size, n%subarray_size);\r\n\t\t\ti++;\r\n            // wypisz_tablice(arr,n,subarray_size);\r\n\t\t}\r\n\r\n\t\t// Find median of all medians using recursive call.\r\n\t\t// If median[] has only one element, then no need\r\n\t\t// of recursive call\r\n\t\tint medOfMed = (i == 1)? median[i-1]:\r\n\t\t\t\t\t\t\t\tSelectDiffSubarrays(median, 0, i-1, i/2, subarray_size);\r\n\r\n\t\t// Partition the array around a random element and\r\n\t\t// get position of pivot element in sorted array\r\n\t\tint pos = partition(arr, l, r, medOfMed);\r\n\r\n\t\t// If position is same as k\r\n\t\tporownania++;\r\n\t\tif (pos-l == k-1)\r\n\t\t\treturn arr[pos];\r\n\t\t\r\n\t\tporownania++;\r\n\t\tif (pos-l > k-1) // If position is more, recur for left\r\n\t\t\treturn SelectDiffSubarrays(arr, l, pos-1, k, subarray_size);\r\n\r\n\t\t// Else recur for right subarray\r\n\t\treturn SelectDiffSubarrays(arr, pos+1, r, k-pos+l-1, subarray_size);\r\n\t}\r\n\r\n\t// If k is more than number of elements in array\r\n\treturn INT_MAX;\r\n}\r\n\r\n// It searches for"]
[81.835562, "o", " x in arr[l..r], and partitions the array\r\n// around x.\r\nint partition(int arr[], int l, int r, int x)\r\n{\r\n\t// Search for x in arr[l..r] and move it to end\r\n\tint i;\r\n\tfor (i=l; i<r; i++){\r\n\t\tporownania++;\r\n\t\tif (arr[i] == x)\r\n\t\tbreak;\r\n\t}\r\n\tprzestawienia++;\r\n\tswap(arr[i], arr[r]);\r\n\r\n\t// Standard partition algorithm\r\n\ti = l;\r\n\tfor (int j = l; j <= r - 1; j++)\r\n\t{\r\n\t\tporownania++;\r\n\t\tif (arr[j] <= x)\r\n\t\t{\r\n\t\t\tprzestawienia++;\r\n\t\t\tswap(arr[i], arr[j]);\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\tprzestawienia++;\r\n\tswap(arr[i], arr[r]);\r\n\treturn i;\r\n}\r\n\r\nvoid merge_over50(int tab[], int l, int m, int r)\r\n{\r\n\r\n    int i = l;\r\n    int j = m + 1;\r\n    int k = l;\r\n\r\n    int tempTab[r];\r\n\r\n    while (i <= m && j <= r)\r\n    {\r\n        if (tab[i] <= tab[j])\r\n        {\r\n            tempTab[k] = tab[i];\r\n            i++;\r\n            k++;\r\n        }\r\n        else\r\n        {\r\n            tempTab[k] = tab[j];\r\n            j++;\r\n            k++;\r\n        }\r\n    }\r\n\r\n    while (i <= m)\r\n    {\r\n        tempTab[k] = tab[i];\r\n        i++;\r\n        k++"]
[81.835653, "o", ";\r\n    }\r\n    while (j <= r)\r\n    {\r\n        tempTab[k] = tab[j];\r\n        j++;\r\n        k++;\r\n    }\r\n\r\n    for (int p = l; p <= r; ++p)\r\n    {\r\n        tab[p] = tempTab[p];\r\n    }\r\n}\r\n\r\nvoid mergeSort_over50(int tab[], int l, int r)\r\n{\r\n    if (l < r)\r\n    {\r\n        int m = (l + r) / 2;\r\n        mergeSort_over50(tab, l, m);\r\n        mergeSort_over50(tab, m + 1, r);\r\n        merge_over50(tab, l, m, r);\r\n    }\r\n}\r\n\r\n// Driver program to test above methods\r\nint main(int argc, char *argv[])\r\n{\r\n\tint n;  // wielkosc tablicy \r\n    int x;  // kolejne elementy tablicy\r\n    int k, i;\r\n    cin >> n;\r\n    int tab[n];\r\n\r\n    cin >> i; // k-th smallest element, we get this from generator\r\n\r\n    k = atoi(argv[1]); //\r\n    int subarray_size = atoi(argv[2]);\r\n\r\n    for (int p = 0; p < n; p++)\r\n    {\r\n        cin >> x;\r\n        tab[p] = x;\r\n    }\r\n    if(n<=50){\r\n        cout<< \"Tablica wejsciowa: \" << endl;\r\n        wypisz_tablice(tab, n,subarray_size);\r\n        cout << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
[81.835726, "o", "~\"<<endl;\r\n        int odp = SelectDiffSubarrays(tab, 0, n-1, k, subarray_size);\r\n        cout << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"<<endl;\r\n        cout << k << \" najmniejszy element tablicy to: \" << odp << endl;\r\n        cout << \"Tablica po wykonaniu selecta: \" << endl;\r\n        wypisz_tablice(tab, n, subarray_size);\r\n        cout << \"Tablica po przesortowaniu: \" << endl;\r\n        mergeSort_over50(tab,0,n-1);\r\n        wypisz_tablice(tab, n, subarray_size);\r\n        cout << \"Licznik przestawien: \" << przestawienia << endl;\r\n        cout << \"Licznik porownan: \" << porownania << endl;\r\n    }\r\n    else{\r\n        const clock_t begin_time = clock(); // time\r\n        int odp = SelectDiffSubarrays(tab, 0, n-1, k, subarray_size);\r\n        const clock_t end_time = clock(); // time\r\n        float dur = float( end_time - begin_time ) /  CLOCKS_PER_SEC;\r\n\r\n        cout << n << \" \"<<porownania<<\" \"<<przestawienia<<\" \"<<dur*1000;\r\n       \r\n        \r\n    }\r\n\treturn 0;\r\n}\r\n"]
[81.835813, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[83.624211, "o", "cat Select_zad3.cpp"]
[83.828561, "o", "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bls\u001b[K"]
[84.561774, "o", "\r\n"]
[84.564038, "o", "ascender.cpp        BS_poczatek_m100.txt      DPQSUpgrade.cpp      QSU_vs_QS_AVG.ods     RandomSelect.cpp  zad3_testy.sh\r\nBinarySearch.cpp    BS_POCZ_SROD_KON_LOS.ods  generator_tests.cpp  QS_VS_QSU_WORST.ods   Select_1.cpp      zad4_testy.sh\r\nBS_koniec_m100.txt  BS_srodek_m100.txt        QS_AVG_m100.txt      QuickSort.cpp         Select_zad3.cpp   zad5_testy.sh\r\nBS_losowy_m100.txt  descender.cpp             QSU_AVG_m100.txt     QuickSortUpgrade.cpp  zad2_testy.sh\r\n"]
[84.564564, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[89.589275, "o", "c"]
[89.81944, "o", "a"]
[90.088446, "o", "t"]
[91.286171, "o", " "]
[92.267911, "o", "R"]
[92.517822, "o", "a"]
[92.982384, "o", "n"]
[93.180871, "o", "d"]
[93.38589, "o", "o"]
[93.639844, "o", "m"]
[94.138524, "o", "S"]
[94.662924, "o", "e"]
[95.061979, "o", "l"]
[95.281547, "o", "e"]
[95.965417, "o", "c"]
[96.188751, "o", "t"]
[97.166579, "o", "."]
[97.725289, "o", "c"]
[97.909823, "o", "p"]
[98.069883, "o", "p"]
[98.593267, "o", "\r\n"]
[98.594892, "o", "#include <iostream>\r\n#include <stdlib.h> \r\n#include <chrono>\r\n\r\nusing namespace std;\r\n\r\nlong int comparisions = 0;\r\nlong int shifts = 0;\r\n\r\nvoid printer (int array[], int n){\r\n    cout<<\"{\";\r\n    for(int i = 0; i < n; i++){\r\n        printf(\"%d, \", array[i]);\r\n    }\r\n    cout<<\"}\\n\";\r\n    return;\r\n}\r\n\r\nint randomPartition(int tab[], int p, int q){\r\n    //srand time(NULL);\r\n    int pivot = tab[p];\r\n    int i = p;\r\n\r\n    for( int j = p + 1; j <= q; j++){\r\n        comparisions++;\r\n        if (tab[j] <= pivot){\r\n            i++;\r\n            if(tab[i] != tab[j]) swap(tab[i], tab[j]);\r\n            shifts++;\r\n        }\r\n    }\r\n\r\n    if (i != p){\r\n            swap(tab[i], tab[p]);\r\n            shifts++;\r\n        }\r\n\r\n    return i;\r\n}\r\n\r\nint randomSelect(int tab[], int p, int q, int i){\r\n    int r;\r\n    int k;\r\n\r\n    if (p == q){\r\n        return tab[p];\r\n    }\r\n\r\n    r = randomPartition(tab, p, q);\r\n    k = r - p + 1;\r\n\r\n    if (k == i) return tab[r];\r\n    if (i < k){\r\n        return randomSelect(tab, p, r - 1, i);\r\n "]
[98.595101, "o", "   }\r\n    else{\r\n        return randomSelect(tab, r + 1, q, i - k);\r\n    }\r\n\r\n}\r\n\r\nint main(int argc, char *argv[]){\r\n\r\n    int i; // = atoi(argv[1]);\r\n    int k = atoi(argv[1]);\r\n\r\n    int n;\r\n    cin >> n;\r\n    cin >> i;\r\n    int mytab[n];\r\n\r\n    for (int i = 0; i < n; i++){\r\n        cin >> mytab[i];\r\n    }\r\n\r\n    // cout<<\"Stan początkowy: \\n\";\r\n    // printer(mytab, n);\r\n\r\n    const clock_t begin_time = clock();\r\n    int wynik = randomSelect(mytab, 0, n - 1, k);\r\n    const clock_t end_time = clock();\r\n    float dur = float( end_time - begin_time ) /  CLOCKS_PER_SEC;\r\n\r\n    // cout<<\"\\nszukana statystyka (\"<<i<<\"-ty min element: \"<<wynik<<endl;\r\n    // cout<<\"Stan końcowy: \\n\";\r\n    // printer(mytab, n);\r\n    cout<<endl<<n<<\" \"<<comparisions<<\" \"<<shifts<<\" \"<<dur*1000<<\" \";\r\n\r\n\r\n    return 0;\r\n\r\n}\r\n"]
[98.595467, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[100.085061, "o", "cat RandomSelect.cpp"]
[100.244855, "o", "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bls\u001b[K"]
[100.948615, "o", "\r\n"]
[100.950957, "o", "ascender.cpp        BS_poczatek_m100.txt      DPQSUpgrade.cpp      QSU_vs_QS_AVG.ods     RandomSelect.cpp  zad3_testy.sh\r\nBinarySearch.cpp    BS_POCZ_SROD_KON_LOS.ods  generator_tests.cpp  QS_VS_QSU_WORST.ods   Select_1.cpp      zad4_testy.sh\r\nBS_koniec_m100.txt  BS_srodek_m100.txt        QS_AVG_m100.txt      QuickSort.cpp         Select_zad3.cpp   zad5_testy.sh\r\nBS_losowy_m100.txt  descender.cpp             QSU_AVG_m100.txt     QuickSortUpgrade.cpp  zad2_testy.sh\r\n"]
[100.951446, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[110.271231, "o", "c"]
[110.490227, "o", "a"]
[110.760052, "o", "t"]
[111.069191, "o", " "]
[116.966012, "o", "z"]
[117.204917, "o", "a"]
[117.494215, "o", "d"]
[119.548896, "o", "2"]
[121.819086, "o", "\b\u001b[K"]
[123.848842, "o", "5"]
[124.452788, "o", "_"]
[125.001184, "o", "t"]
[125.275979, "o", "e"]
[125.47553, "o", "s"]
[125.754512, "o", "t"]
[125.96929, "o", "y"]
[126.622308, "o", "."]
[126.877738, "o", "s"]
[127.116649, "o", "h"]
[127.754674, "o", "\r\n"]
[127.756339, "o", "#!/bin/bash\r\n\r\nm=$1\r\n\r\nrm dane/QS_worst_m$m.txt\r\nrm dane/QSU_worst_m$m.txt\r\n\r\n\r\n\r\necho \"n porównania przestawienia czas\" >> dane/QS_worst_m$m.txt\r\necho \"n porównania przestawienia czas\" >> dane/QSU_worst_m$m.txt\r\n\r\n\r\n\r\nfor n in {100..100000..100}\r\ndo\r\n    echo \"przejscie $n\"\r\n    for i in $( eval echo {1..$m})\r\n    do\r\n        ./desc $n >> dane/randomtab.txt\r\n        # 'blisko początku'\r\n        cat dane/randomtab.txt | ./QS >> dane/QS_worst_m$m.txt      \r\n        # 'blisko końca'\r\n        cat dane/randomtab.txt | ./QSU >> dane/QSU_worst_m$m.txt\r\n\r\n        rm dane/randomtab.txt\r\n    done\r\ndone\r\n"]
[127.756668, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[129.420741, "o", "cat zad5_testy.sh"]
[129.715536, "o", "\b"]
[129.944471, "o", "\b"]
[130.119272, "o", "\b"]
[130.273776, "o", "\b"]
[130.433847, "o", "\b"]
[130.587998, "o", "\b"]
[130.742626, "o", "\b"]
[130.913733, "o", "\b"]
[131.087308, "o", "\b"]
[131.805684, "o", "\b\u001b[1P_testy.sh\b\b\b\b\b\b\b\b\b"]
[132.319404, "o", "4_testy.sh\b\b\b\b\b\b\b\b\b"]
[133.276493, "o", "\r\n"]
[133.278033, "o", "#!/bin/bash\r\n\r\nm=$1\r\n\r\nrm dane/BS_poczatek_m$m.txt\r\nrm dane/BS_koniec_m$m.txt\r\nrm dane/BS_srodek_m$m.txt\r\nrm dane/BS_losowy_m$m.txt\r\n\r\n\r\necho \"n porównania czas\" >> dane/BS_poczatek_m$m.txt\r\necho \"n porównania czas\" >> dane/BS_koniec_m$m.txt\r\necho \"n porównania czas\" >> dane/BS_srodek_m$m.txt\r\necho \"n porównania czas\" >> dane/BS_losowy_m$m.txt\r\n\r\n\r\nfor n in {1000..100000..1000}\r\ndo\r\n    echo \"przejscie $n\"\r\n    for i in $( eval echo {1..$m})\r\n    do\r\n        ./generator $n >> dane/randomtab.txt\r\n        # 'blisko początku'\r\n        cat dane/randomtab.txt | ./BS 1 >> dane/BS_poczatek_m$m.txt      \r\n        # 'blisko końca'\r\n        cat dane/randomtab.txt | ./BS 2 >> dane/BS_koniec_m$m.txt\r\n        # 'okolo środka'\r\n        cat dane/randomtab.txt | ./BS 3 >> dane/BS_srodek_m$m.txt\r\n        # 'losowy z całej tablicy'\r\n        cat dane/randomtab.txt | ./BS 0 >> dane/BS_losowy_m$m.txt\r\n\r\n        rm dane/randomtab.txt\r\n    done\r\ndone\r\n"]
[133.278538, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[134.194861, "o", "cat zad4_testy.sh"]
[134.444043, "o", "\b"]
[134.618297, "o", "\b"]
[134.773542, "o", "\b"]
[134.929956, "o", "\b"]
[135.087773, "o", "\b"]
[135.241879, "o", "\b"]
[135.397116, "o", "\b"]
[135.566812, "o", "\b"]
[135.731515, "o", "\b"]
[136.713492, "o", "\b\u001b[1P_testy.sh\b\b\b\b\b\b\b\b\b"]
[136.925139, "o", "3_testy.sh\b\b\b\b\b\b\b\b\b"]
[137.562028, "o", "\r\n"]
[137.563655, "o", "#!/bin/bash\r\n\r\nm=$1\r\n\r\nrm dane/select_min_k3.txt\r\nrm dane/select_mid_k3.txt\r\nrm dane/select_max_k3.txt\r\n\r\nrm dane/select_min_k5.txt\r\nrm dane/select_mid_k5.txt\r\nrm dane/select_max_k5.txt\r\n\r\nrm dane/select_min_k7.txt\r\nrm dane/select_mid_k7.txt\r\nrm dane/select_max_k7.txt\r\n\r\nrm dane/select_min_k9.txt\r\nrm dane/select_mid_k9.txt\r\nrm dane/select_max_k9.txt\r\n\r\n\r\necho \"n przestawienia porównania czas\" >> dane/select_min_k3.txt\r\necho \"n przestawienia porównania czas\" >> dane/select_mid_k3.txt\r\necho \"n przestawienia porównania czas\" >> dane/select_max_k3.txt\r\n\r\necho \"n przestawienia porównania czas\" >> dane/select_min_k5.txt\r\necho \"n przestawienia porównania czas\" >> dane/select_mid_k5.txt\r\necho \"n przestawienia porównania czas\" >> dane/select_max_k5.txt\r\n\r\necho \"n przestawienia porównania czas\" >> dane/select_min_k7.txt\r\necho \"n przestawienia porównania czas\" >> dane/select_mid_k7.txt\r\necho \"n przestawienia porównania czas\" >> dane/select_max_k7.txt\r\n\r\necho \"n przestawienia porównania czas\" >> dane/select_min"]
[137.563756, "o", "_k9.txt\r\necho \"n przestawienia porównania czas\" >> dane/select_mid_k9.txt\r\necho \"n przestawienia porównania czas\" >> dane/select_max_k9.txt\r\n\r\nfor n in {100..10000..100}\r\ndo\r\n\tmin=$(echo 1)\r\n    mid=$(echo $n /2 | bc)\r\n    max=$n\r\n    echo \"min = $min, max = $max, mid = $mid\"\r\n    for i in $( eval echo {1..$m} )\r\n    do\r\n        ./rtab $n >> dane/randomtab.txt\r\n\r\n        cat dane/randomtab.txt | ./Select_zad3 $min 3 >> dane/select_min_k3.txt\r\n        cat dane/randomtab.txt | ./Select_zad3 $mid 3 >> dane/select_mid_k3.txt\r\n        cat dane/randomtab.txt | ./Select_zad3 $max 3 >> dane/select_max_k3.txt\r\n\r\n        cat dane/randomtab.txt | ./Select_zad3 $min 5 >> dane/select_min_k5.txt\r\n        cat dane/randomtab.txt | ./Select_zad3 $mid 5 >> dane/select_mid_k5.txt\r\n        cat dane/randomtab.txt | ./Select_zad3 $max 5 >> dane/select_max_k5.txt\r\n\r\n        cat dane/randomtab.txt | ./Select_zad3 $min 7 >> dane/select_min_k7.txt\r\n        cat dane/randomtab.txt | ./Select_zad3 $mid 7 >> dane/select_mid_k7.txt\r\n    "]
[137.563923, "o", "    cat dane/randomtab.txt | ./Select_zad3 $max 7 >> dane/select_max_k7.txt\r\n        \r\n        cat dane/randomtab.txt | ./Select_zad3 $min 9 >> dane/select_min_k9.txt\r\n        cat dane/randomtab.txt | ./Select_zad3 $mid 9 >> dane/select_mid_k9.txt\r\n        cat dane/randomtab.txt | ./Select_zad3 $max 9 >> dane/select_max_k9.txt\r\n\r\n        rm dane/randomtab.txt\r\n    done\r\ndone"]
[137.564187, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[138.894776, "o", "cat zad3_testy.sh"]
[139.257944, "o", "\b"]
[139.432546, "o", "\b"]
[139.59165, "o", "\b"]
[139.746815, "o", "\b"]
[139.902395, "o", "\b"]
[140.061058, "o", "\b"]
[140.223643, "o", "\b"]
[140.379634, "o", "\b"]
[140.559465, "o", "\b"]
[141.197838, "o", "\b\u001b[1P_testy.sh\b\b\b\b\b\b\b\b\b"]
[142.000848, "o", "2_testy.sh\b\b\b\b\b\b\b\b\b"]
[142.335564, "o", "\r\n"]
[142.337146, "o", "#!/bin/bash\r\n\r\nm=$1\r\n\r\nrm dane/select_min_m$m.txt\r\nrm dane/select_mid_m$m.txt\r\nrm dane/select_max_m$m.txt\r\n\r\nrm dane/randomselect_min_m$m.txt\r\nrm dane/randomselect_mid_m$m.txt\r\nrm dane/randomselect_max_m$m.txt\r\n\r\necho \"n przestawienia porównania\" >> dane/select_min_m$m.txt\r\necho \"n przestawienia porównania\" >> dane/select_mid_m$m.txt\r\necho \"n przestawienia porównania\" >> dane/select_max_m$m.txt\r\n\r\necho \"n przestawienia porównania\" >> dane/randomselect_min_m$m.txt\r\necho \"n przestawienia porównania\" >> dane/randomselect_mid_m$m.txt\r\necho \"n przestawienia porównania\" >> dane/randomselect_max_m$m.txt\r\n\r\n\r\nfor n in {100..10000..100}\r\ndo\r\n\tmin=$(echo 1)\r\n    mid=$(echo $n /2 | bc)\r\n    max=$n\r\n    echo \"min = $min, max = $max, mid = $mid\"\r\n    for i in $( eval echo {1..$m} )\r\n    do\r\n        ./generator $n >> dane/randomtab.txt\r\n        cat dane/randomtab.txt | ./Select_1 $min >> dane/select_min_m$m.txt\r\n        cat dane/randomtab.txt | ./Select_1 $mid >> dane/select_mid_m$m.txt\r\n        cat dane/randomtab.tx"]
[142.337344, "o", "t | ./Select_1 $max >> dane/select_max_m$m.txt\r\n\r\n        cat dane/randomtab.txt | ./RandomSelect $min >> dane/randomselect_min_m$m.txt\r\n        cat dane/randomtab.txt | ./RandomSelect $mid >> dane/randomselect_mid_m$m.txt\r\n        cat dane/randomtab.txt | ./RandomSelect $max >> dane/randomselect_max_m$m.txt\r\n        rm dane/randomtab.txt\r\n    done\r\ndone"]
[142.337521, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[146.415247, "o", "l"]
[146.600242, "o", "s"]
[146.835762, "o", "\r\n"]
[146.838078, "o", "ascender.cpp        BS_poczatek_m100.txt      DPQSUpgrade.cpp      QSU_vs_QS_AVG.ods     RandomSelect.cpp  zad3_testy.sh\r\nBinarySearch.cpp    BS_POCZ_SROD_KON_LOS.ods  generator_tests.cpp  QS_VS_QSU_WORST.ods   Select_1.cpp      zad4_testy.sh\r\nBS_koniec_m100.txt  BS_srodek_m100.txt        QS_AVG_m100.txt      QuickSort.cpp         Select_zad3.cpp   zad5_testy.sh\r\nBS_losowy_m100.txt  descender.cpp             QSU_AVG_m100.txt     QuickSortUpgrade.cpp  zad2_testy.sh\r\n"]
[146.838515, "o", "\u001b]0;aleksander@CzadowyOlo: ~/aisd/261702/lab3\u0007\u001b[01;32maleksander@CzadowyOlo\u001b[00m:\u001b[01;34m~/aisd/261702/lab3\u001b[00m$ "]
[149.044716, "o", "e"]
[149.398877, "o", "x"]
[149.688052, "o", "i"]
[150.006801, "o", "t"]
[156.097237, "o", "\r\n"]
[156.09746, "o", "exit\r\n"]
